<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statement Generator</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/arquero@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/exceljs@latest/dist/exceljs.min.js"></script>
    
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-size: 13px;
        }

        #app {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .section {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            transition: box-shadow 0.3s ease;
        }

        .section:hover {
            box-shadow: 0 10px 15px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.1);
        }

        h2 {
            margin-bottom: 12px;
            color: #2d3748;
            font-size: 1.1em;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 6px;
        }

        .directory-selection {
            margin-bottom: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-right: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(245, 87, 108, 0.4);
        }

        .btn:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .status-text {
            color: #666;
            font-size: 12px;
        }

        .file-loading {
            margin-bottom: 12px;
        }

        .loading-status {
            margin-top: 8px;
            min-height: 18px;
            color: #666;
            font-size: 12px;
        }

        .file-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .file-status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 4px;
            border-left: 3px solid #667eea;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .file-status-item.clickable {
            cursor: pointer;
        }

        .file-status-item.clickable:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }

        .file-status-item.clickable.loaded {
            cursor: pointer;
        }

        .file-status-item:not(.clickable):hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        #data-preview th {
            background-color: #667eea;
            color: white;
            padding: 6px 8px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        #data-preview td {
            padding: 4px 8px;
            border-bottom: 1px solid #e9ecef;
        }

        #data-preview tr:hover {
            background-color: #f8f9fa;
        }

        .file-label {
            font-weight: 600;
            color: #2d3748;
        }

        .status-indicator {
            font-size: 12px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 3px;
        }

        .tab-btn {
            padding: 8px 16px;
            border: none;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: 4px 4px 0 0;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            color: #4a5568;
        }

        .tab-btn:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            transform: translateY(-1px);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-color: #667eea;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .statement-display {
            min-height: 400px;
            overflow-x: auto;
        }

        .financial-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .financial-table th {
            background-color: #007bff;
            color: white;
            padding: 8px 6px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        .financial-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .financial-table th.sortable:hover {
            background-color: #0056b3;
        }

        .financial-table th.col-number {
            text-align: right;
        }

        .financial-table td {
            padding: 6px;
            border-bottom: 1px solid #e9ecef;
        }

        .financial-table td.number {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .financial-table td.indent {
            padding-left: 24px;
        }

        .financial-table tr.detail-row:hover {
            background-color: #f8f9fa;
        }

        .financial-table tr.category-header td {
            background-color: #e9ecef;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #007bff;
        }

        .financial-table tr.subtotal-row td {
            background-color: #f8f9fa;
            border-top: 2px solid #333;
            border-bottom: 2px solid #333;
            padding: 8px 6px;
        }

        .financial-table tr.total-row td {
            background-color: #e7f3ff;
            border-top: 3px double #007bff;
            border-bottom: 3px double #007bff;
            padding: 8px 6px;
            font-size: 13px;
        }

        .financial-table tr.metric-row td {
            background-color: #fff3cd;
            padding: 8px 6px;
        }

        .financial-table tr.section-header td {
            background-color: #d1ecf1;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #0c5460;
        }

        .financial-table tr.spacer-row td {
            padding: 3px;
            border: none;
        }

        .financial-table tr.info-row td {
            padding: 8px 6px;
            text-align: center;
            font-weight: 500;
        }

        .financial-table .positive {
            color: #28a745;
        }

        .financial-table .negative {
            color: #dc3545;
        }

        .success-message {
            color: #28a745;
            background-color: #d4edda;
        }

        .warning-message {
            color: #856404;
            background-color: #fff3cd;
        }

        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .tooltip-content {
            line-height: 1.5;
        }

        .export-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .validation-messages {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            font-size: 12px;
        }

        .validation-errors {
            margin-bottom: 8px;
        }

        .validation-errors:empty {
            display: none;
        }

        .validation-warnings:empty {
            display: none;
        }

        .validation-error-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #f8d7da;
            color: #721c24;
            border-left: 3px solid #dc3545;
            border-radius: 3px;
        }

        .validation-warning-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #fff3cd;
            color: #856404;
            border-left: 3px solid #ffc107;
            border-radius: 3px;
        }

        .unmapped-accounts-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 5px;
            padding: 8px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Statement Generator <span style="font-size: 0.6em; color: rgba(255,255,255,0.8);">v2.0.0</span></h1>
        
        <!-- File Upload Section -->
        <div id="file-upload-section" class="section">
            <h2>Data Files</h2>
            
            <div class="directory-selection">
                <button id="select-input-dir" class="btn btn-primary">Select Directory</button>
                <button id="load-all-files" class="btn btn-secondary" disabled>Load Files</button>
                <span id="input-dir-status" class="status-text"></span>
                <div id="loading-status" class="loading-status"></div>
            </div>
            
            <div class="file-status-grid">
                <div class="file-status-item clickable" data-file="tb2024">
                    <span class="file-label">TB 2024</span>
                    <span id="status-tb2024" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="tb2025">
                    <span class="file-label">TB 2025</span>
                    <span id="status-tb2025" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="tb2425">
                    <span class="file-label">TB 2024+2025</span>
                    <span id="status-tb2425" class="status-indicator">üëÅÔ∏è</span>
                </div>
                <div class="file-status-item clickable" data-file="tb24m">
                    <span class="file-label">TB24_M (Movements)</span>
                    <span id="status-tb24m" class="status-indicator">üëÅÔ∏è</span>
                </div>
                <div class="file-status-item clickable" data-file="tb24b">
                    <span class="file-label">TB24_B (Balances)</span>
                    <span id="status-tb24b" class="status-indicator">üëÅÔ∏è</span>
                </div>
                <div class="file-status-item clickable" data-file="tb25m">
                    <span class="file-label">TB25_M (Movements)</span>
                    <span id="status-tb25m" class="status-indicator">üëÅÔ∏è</span>
                </div>
                <div class="file-status-item clickable" data-file="tb25b">
                    <span class="file-label">TB25_B (Balances)</span>
                    <span id="status-tb25b" class="status-indicator">üëÅÔ∏è</span>
                </div>
                <div class="file-status-item clickable" data-file="hierarchy">
                    <span class="file-label">Accounts</span>
                    <span id="status-hierarchy" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="dates">
                    <span class="file-label">Dates</span>
                    <span id="status-dates" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="format">
                    <span class="file-label">Format</span>
                    <span id="status-format" class="status-indicator">‚ö™</span>
                </div>
            </div>
            
            <!-- Data Preview Section -->
            <div id="data-preview" style="display: none; margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 4px; max-height: 400px; overflow: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong id="preview-title" style="font-size: 13px;"></strong>
                    <button id="close-preview" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #666;">√ó</button>
                </div>
                <div id="preview-content"></div>
            </div>

            <!-- Validation Messages -->
            <div id="validation-messages" class="validation-messages" style="display: none;">
                <div id="validation-errors" class="validation-errors"></div>
                <div id="validation-warnings" class="validation-warnings"></div>
            </div>
        </div>

        <!-- Statement Display Section -->
        <div id="statement-section" class="section" style="display: none;">
            <h2>Statements</h2>
            <div id="statement-tabs" class="tabs">
                <button class="tab-btn active" data-statement="balance-sheet">Balance Sheet</button>
                <button class="tab-btn" data-statement="income-statement">Income Statement</button>
                <button class="tab-btn" data-statement="cash-flow">Cash Flow</button>
            </div>
            <div id="statement-display" class="statement-display"></div>
            
            <!-- Export Controls -->
            <div class="export-controls">
                <button id="export-current" class="btn btn-secondary">Export Current</button>
                <button id="export-all" class="btn btn-secondary">Export All</button>
                <span id="export-status" class="status-text"></span>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const STATEMENT_TYPES = {
            BALANCE_SHEET: 'BS',
            INCOME_STATEMENT: 'IS',
            CASH_FLOW: 'CF'
        };

        const EXCEL_COLUMNS = {
            STATEMENT_TYPE: 4,
            LEVEL1_CODE: 5,
            LEVEL1_LABEL: 6,
            LEVEL2_CODE: 7,
            LEVEL2_LABEL: 8,
            LEVEL3_CODE: 9,
            LEVEL3_LABEL: 10,
            ACCOUNT_CODE: 11,
            ACCOUNT_DESCRIPTION: 12
        };

        // Configuration
        let config = null;

        // DataStore class for state management (Singleton pattern)
        class DataStore {
            constructor() {
                if (DataStore.instance) {
                    return DataStore.instance;
                }
                
                this.factTables = {}; // Store FactTables by period and type: {2024: {movements: table, balances: table}, 2025: {...}}
                this.hierarchyTable = null;
                this.datesTable = null;
                this.formatTable = null;
                
                DataStore.instance = this;
            }

            // Store FactTable for a specific period and type
            setFactTable(table, period, type = 'movements') {
                if (!this.factTables[period]) {
                    this.factTables[period] = {};
                }
                this.factTables[period][type] = table;
                console.log(`FactTable ${type} for ${period} stored (${table.numRows()} rows)`);
            }

            // Retrieve FactTable for a specific period and type
            getFactTable(period, type = 'movements') {
                return this.factTables[period]?.[type] || null;
            }

            // Shorthand: Get movements table for a period
            getMovementsTable(period) {
                return this.getFactTable(period, 'movements');
            }

            // Shorthand: Get balances table for a period
            getBalancesTable(period) {
                return this.getFactTable(period, 'balances');
            }

            // Get row counts for verification
            getRowCounts(period) {
                const movements = this.getMovementsTable(period);
                const balances = this.getBalancesTable(period);
                return {
                    movements: movements ? movements.numRows() : 0,
                    balances: balances ? balances.numRows() : 0
                };
            }

            // Store Hierarchy Table
            setHierarchyTable(table) {
                this.hierarchyTable = table;
                console.log('Hierarchy Table stored');
            }

            // Retrieve Hierarchy Table
            getHierarchyTable() {
                return this.hierarchyTable;
            }

            // Store Dates Table
            setDatesTable(table) {
                this.datesTable = table;
                console.log('Dates Table stored');
            }

            // Retrieve Dates Table
            getDatesTable() {
                return this.datesTable;
            }

            // Store Format Table
            setFormatTable(table) {
                this.formatTable = table;
                console.log('Format Table stored');
            }

            // Retrieve Format Table
            getFormatTable() {
                return this.formatTable;
            }

            // Get all loaded periods
            getAllPeriods() {
                return Object.keys(this.factTables);
            }

            // Check if all required data is loaded
            isDataComplete() {
                const has2024Movements = this.factTables['2024']?.movements;
                const has2024Balances = this.factTables['2024']?.balances;
                const has2025Movements = this.factTables['2025']?.movements;
                const has2025Balances = this.factTables['2025']?.balances;
                const hasBothPeriods = has2024Movements && has2024Balances && has2025Movements && has2025Balances;
                const hasAllTables = this.hierarchyTable && this.datesTable && this.formatTable;
                return hasBothPeriods && hasAllTables;
            }

            // Clear all data
            clear() {
                this.factTables = {};
                this.hierarchyTable = null;
                this.datesTable = null;
                this.formatTable = null;
                console.log('DataStore cleared');
            }
        }
        
        // Load configuration file
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                config = await response.json();
                console.log('Configuration loaded:', config);
                return config;
            } catch (error) {
                console.error('Error loading config:', error);
                // Use default configuration
                config = {
                    inputFiles: {
                        trialBalance2024: "2024_BalansenWinstverliesperperiode.xlsx",
                        trialBalance2025: "2025_BalansenWinstverliesperperiode.xlsx",
                        hierarchy: "DimAccounts.xlsx",
                        dates: "DimDates.xlsx",
                        format: "format.xlsx"
                    },
                    outputFiles: {
                        balanceSheet: "balance_sheet.xlsx",
                        incomeStatement: "income_statement.xlsx",
                        cashFlowStatement: "cash_flow_statement.xlsx",
                        allStatements: "financial_statements_all.xlsx"
                    },
                    directories: {
                        input: "input",
                        output: "output"
                    }
                };
                return config;
            }
        }

        // DataLoader class for Excel file parsing with directory access
        class DataLoader {
            constructor() {
                this.inputDirHandle = null;
                this.outputDirHandle = null;
                
                // Dutch month names to period numbers mapping
                this.MONTH_MAP = {
                    'januari': 1,
                    'februari': 2,
                    'maart': 3,
                    'april': 4,
                    'mei': 5,
                    'juni': 6,
                    'juli': 7,
                    'augustus': 8,
                    'september': 9,
                    'oktober': 10,
                    'november': 11,
                    'december': 12
                };
            }

            // Request access to input directory
            async selectInputDirectory() {
                try {
                    this.inputDirHandle = await window.showDirectoryPicker({
                        mode: 'read',
                        startIn: 'documents'
                    });
                    console.log('Input directory selected:', this.inputDirHandle.name);
                    return this.inputDirHandle;
                } catch (error) {
                    console.error('Error selecting input directory:', error);
                    throw new Error('Failed to select input directory');
                }
            }

            // Request access to output directory
            async selectOutputDirectory() {
                try {
                    this.outputDirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });
                    console.log('Output directory selected:', this.outputDirHandle.name);
                    return this.outputDirHandle;
                } catch (error) {
                    console.error('Error selecting output directory:', error);
                    throw new Error('Failed to select output directory');
                }
            }

            // Read file from input directory
            async readFileFromDirectory(filename) {
                if (!this.inputDirHandle) {
                    throw new Error('Input directory not selected. Please select input directory first.');
                }

                try {
                    const fileHandle = await this.inputDirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    return file;
                } catch (error) {
                    console.error(`Error reading file ${filename}:`, error);
                    throw new Error(`File not found: ${filename}`);
                }
            }

            // Validate required columns in Excel data
            validateColumns(data, requiredColumns) {
                if (!data || data.length === 0) {
                    throw new Error('File is empty or invalid');
                }

                const firstRow = data[0];
                const actualColumns = Object.keys(firstRow);
                const missingColumns = requiredColumns.filter(col => !actualColumns.includes(col));

                if (missingColumns.length > 0) {
                    throw new Error(`File missing required columns: ${missingColumns.join(', ')}`);
                }

                return true;
            }

            // Map month name and year to period number
            mapMonthToPeriod(columnName, year) {
                const lowerCol = String(columnName).toLowerCase();
                
                // Check for "Voorafgaandejournaalposten" - map to period 12 (December)
                if (lowerCol.includes('voorafgaandejournaalposten') || lowerCol.includes('voorafgaande')) {
                    if (lowerCol.includes(year)) {
                        return {
                            period: 12,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for month patterns (e.g., "januari2024", "februari2024")
                for (const [monthName, periodNum] of Object.entries(this.MONTH_MAP)) {
                    if (lowerCol.includes(monthName) && lowerCol.includes(year)) {
                        return {
                            period: periodNum,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for balance indicators
                if (lowerCol.includes('saldo') || lowerCol.includes('balance')) {
                    return {
                        period: 12, // End of year
                        year: parseInt(year),
                        type: 'balance'
                    };
                }
                
                return null;
            }

            // Identify period columns from headers
            identifyPeriodColumns(headers, year) {
                const movements = [];
                const balances = [];
                
                headers.forEach((header, index) => {
                    if (!header) return;
                    
                    const mapping = this.mapMonthToPeriod(header, year);
                    if (mapping) {
                        if (mapping.type === 'movement') {
                            movements.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        } else if (mapping.type === 'balance') {
                            balances.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        }
                    }
                });
                
                return { movements, balances };
            }

            // Transform wide format data to long format
            transformWideToLong(worksheet, year) {
                const movements = [];
                const balances = [];
                
                // Get headers from first row
                const headers = [];
                const headerRow = worksheet.getRow(1);
                headerRow.eachCell((cell, colNumber) => {
                    headers[colNumber] = cell.value;
                });
                
                // Identify period columns
                const periodColumns = this.identifyPeriodColumns(headers, year);
                
                console.log(`Found ${periodColumns.movements.length} movement columns and ${periodColumns.balances.length} balance columns for ${year}`);
                
                // Process each data row
                worksheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // Skip header row
                    
                    const accountCode = row.getCell(EXCEL_COLUMNS.ACCOUNT_CODE).value;
                    const accountDescription = row.getCell(EXCEL_COLUMNS.ACCOUNT_DESCRIPTION).value;
                    
                    if (!accountCode) return;
                    
                    // Extract hierarchy columns
                    const statementType = row.getCell(EXCEL_COLUMNS.STATEMENT_TYPE).value;
                    const level1Code = row.getCell(EXCEL_COLUMNS.LEVEL1_CODE).value;
                    const level1Label = row.getCell(EXCEL_COLUMNS.LEVEL1_LABEL).value;
                    const level2Code = row.getCell(EXCEL_COLUMNS.LEVEL2_CODE).value;
                    const level2Label = row.getCell(EXCEL_COLUMNS.LEVEL2_LABEL).value;
                    const level3Code = row.getCell(EXCEL_COLUMNS.LEVEL3_CODE).value;
                    const level3Label = row.getCell(EXCEL_COLUMNS.LEVEL3_LABEL).value;
                    
                    // Determine statement type
                    let stmtType = STATEMENT_TYPES.INCOME_STATEMENT; // Default
                    if (statementType === 'Balans') {
                        stmtType = STATEMENT_TYPES.BALANCE_SHEET;
                    } else if (statementType === 'Winst & verlies') {
                        stmtType = STATEMENT_TYPES.INCOME_STATEMENT;
                    }
                    
                    // Create base row with hierarchy
                    const baseRow = {
                        account_code: String(accountCode),
                        account_description: String(accountDescription ?? ''),
                        statement_type: stmtType,
                        level1_code: level1Code !== null && level1Code !== undefined ? String(level1Code) : '',
                        level1_label: level1Label ?? '',
                        level2_code: level2Code !== null && level2Code !== undefined ? String(level2Code) : '',
                        level2_label: level2Label ?? '',
                        level3_code: level3Code !== null && level3Code !== undefined ? String(level3Code) : '',
                        level3_label: level3Label ?? '',
                        category: (level1Label ?? '').toString(),
                        subcategory: (level2Label ?? level1Label ?? '').toString()
                    };
                    
                    // Process movement columns
                    periodColumns.movements.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            movements.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                movement_amount: Number(value)
                            });
                        }
                    });
                    
                    // Process balance columns
                    periodColumns.balances.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            balances.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                balance_amount: Number(value)
                            });
                        }
                    });
                });
                
                console.log(`Transformed to ${movements.length} movement rows and ${balances.length} balance rows`);
                
                return { movements, balances };
            }

            // Load trial balance amounts for a specific period
            async loadTrialBalance(period) {
                const filename = period === '2024' 
                    ? config.inputFiles.trialBalance2024 
                    : config.inputFiles.trialBalance2025;

                try {
                    const file = await this.readFileFromDirectory(filename);
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    const worksheet = workbook.worksheets[0];
                    
                    console.log(`Transforming ${filename} from wide to long format...`);
                    
                    // Transform wide format to long format
                    const { movements, balances } = this.transformWideToLong(worksheet, period);
                    
                    // Convert arrays to Arquero tables
                    const movementsTable = aq.from(movements);
                    const balancesTable = aq.from(balances);
                    
                    console.log(`Trial Balance ${period} loaded:`);
                    console.log(`  - Movements: ${movementsTable.numRows()} rows`);
                    console.log(`  - Balances: ${balancesTable.numRows()} rows`);
                    
                    return {
                        movements: movementsTable,
                        balances: balancesTable
                    };

                } catch (error) {
                    console.error(`Error loading trial balance for ${period}:`, error);
                    throw error;
                }
            }

            // Load Dates from Excel file (filtered by loaded years)
            async loadDates(loadedYears = ['2024', '2025']) {
                const filename = config.inputFiles.dates;

                try {
                    const file = await this.readFileFromDirectory(filename);
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    const worksheet = workbook.worksheets[0];
                    const data = [];

                    const headers = [];
                    worksheet.getRow(1).eachCell((cell, colNumber) => {
                        headers[colNumber] = cell.value;
                    });

                    worksheet.eachRow((row, rowNumber) => {
                        if (rowNumber === 1) return;
                        
                        const rowData = {};
                        row.eachCell((cell, colNumber) => {
                            const header = headers[colNumber];
                            if (header) {
                                rowData[header] = cell.value;
                            }
                        });
                        
                        if (Object.keys(rowData).length > 0) {
                            data.push(rowData);
                        }
                    });

                    // Transform DimDates format to expected dates format
                    // Extract unique years and filter to only loaded years
                    const years = new Set();
                    data.forEach(row => {
                        if (row.Year) {
                            const yearStr = String(row.Year);
                            // Only include years that were loaded in trial balance
                            if (loadedYears.includes(yearStr)) {
                                years.add(row.Year);
                            }
                        }
                    });

                    console.log(`Filtering dates to loaded years: ${loadedYears.join(', ')}`);
                    console.log(`Found ${years.size} matching years in DimDates`);

                    const transformedData = Array.from(years).map(year => {
                        // Find first and last date for this year
                        const yearRows = data.filter(row => row.Year === year);
                        const dates = yearRows.map(row => row.Date).filter(d => d);
                        
                        // Convert Excel serial dates to JavaScript dates if needed
                        const convertExcelDate = (serial) => {
                            if (typeof serial === 'number') {
                                // Excel serial date (days since 1900-01-01)
                                const excelEpoch = new Date(1900, 0, 1);
                                const date = new Date(excelEpoch.getTime() + (serial - 2) * 24 * 60 * 60 * 1000);
                                return date;
                            }
                            return new Date(serial);
                        };

                        const firstDate = dates.length > 0 ? convertExcelDate(Math.min(...dates)) : new Date(year, 0, 1);
                        const lastDate = dates.length > 0 ? convertExcelDate(Math.max(...dates)) : new Date(year, 11, 31);

                        return {
                            period: String(year),
                            year: year,
                            period_start: firstDate.toISOString().split('T')[0],
                            period_end: lastDate.toISOString().split('T')[0]
                        };
                    });

                    const table = aq.from(transformedData);
                    console.log('Dates loaded:', table.numRows(), 'rows (filtered to loaded years)');
                    return table;

                } catch (error) {
                    console.error('Error loading dates:', error);
                    throw error;
                }
            }

            // Load Format from Excel file
            async loadFormat() {
                const filename = config.inputFiles.format;

                try {
                    const file = await this.readFileFromDirectory(filename);
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    const worksheet = workbook.worksheets[0];
                    const data = [];

                    const headers = [];
                    worksheet.getRow(1).eachCell((cell, colNumber) => {
                        headers[colNumber] = cell.value;
                    });

                    worksheet.eachRow((row, rowNumber) => {
                        if (rowNumber === 1) return;
                        
                        const rowData = {};
                        row.eachCell((cell, colNumber) => {
                            const header = headers[colNumber];
                            if (header) {
                                rowData[header] = cell.value;
                            }
                        });
                        
                        if (Object.keys(rowData).length > 0) {
                            data.push(rowData);
                        }
                    });

                    this.validateColumns(data, ['statement_type', 'line_number', 'line_type', 'line_label']);

                    const table = aq.from(data);
                    console.log('Format loaded:', table.numRows(), 'rows');
                    return table;

                } catch (error) {
                    console.error('Error loading format:', error);
                    throw error;
                }
            }
        }

        // StatementGenerator class for generating financial statements
        class StatementGenerator {
            constructor(dataStore) {
                this.dataStore = dataStore;
                this.unmappedAccounts = [];
            }

            // Helper: Calculate variance percentage
            calculateVariancePercent(amt2024, amt2025) {
                return amt2024 !== 0 ? ((amt2025 - amt2024) / Math.abs(amt2024)) * 100 : 0;
            }

            // Helper: Validate required data is loaded
            validateRequiredData() {
                const factTable2024 = this.dataStore.getFactTable('2024');
                const factTable2025 = this.dataStore.getFactTable('2025');
                
                if (!factTable2024 || !factTable2025) {
                    throw new Error('Required data not loaded');
                }
                
                return { factTable2024, factTable2025 };
            }

            // Helper: Group and aggregate data for a period
            groupByPeriod(table, period, groupColumns = ['category', 'subcategory']) {
                return table
                    .groupby(...groupColumns)
                    .rollup({ [`amount_${period}`]: d => aq.op.sum(d.movement_amount) })
                    .select(...groupColumns, `amount_${period}`);
            }

            // Helper: Calculate variance columns
            deriveVarianceColumns(combined) {
                return combined.derive({
                    amount_2024: d => d.amount_2024 || 0,
                    amount_2025: d => d.amount_2025 || 0,
                    variance_amount: d => (d.amount_2025 || 0) - (d.amount_2024 || 0),
                    variance_percent: d => this.calculateVariancePercent(d.amount_2024 || 0, d.amount_2025 || 0)
                });
            }

            // Helper: Calculate category totals
            calculateCategoryTotals(combined) {
                return combined
                    .groupby('category')
                    .rollup({
                        amount_2024: d => aq.op.sum(d.amount_2024),
                        amount_2025: d => aq.op.sum(d.amount_2025),
                        variance_amount: d => aq.op.sum(d.variance_amount),
                        variance_percent: d => {
                            const total2024 = aq.op.sum(d.amount_2024);
                            const total2025 = aq.op.sum(d.amount_2025);
                            return this.calculateVariancePercent(total2024, total2025);
                        }
                    });
            }

            // Detect unmapped accounts
            detectUnmappedAccounts() {
                try {
                    const factTable2024 = this.dataStore.getFactTable('2024');
                    const factTable2025 = this.dataStore.getFactTable('2025');
                    const hierarchyTable = this.dataStore.getHierarchyTable();

                    if (!factTable2024 || !factTable2025 || !hierarchyTable) {
                        return [];
                    }

                    // Get all account codes from hierarchy
                    const hierarchyAccounts = new Set(
                        hierarchyTable.array('account_code')
                    );

                    // Check 2024 accounts
                    const accounts2024 = factTable2024.array('account_code');
                    const unmapped2024 = accounts2024.filter(code => !hierarchyAccounts.has(code));

                    // Check 2025 accounts
                    const accounts2025 = factTable2025.array('account_code');
                    const unmapped2025 = accounts2025.filter(code => !hierarchyAccounts.has(code));

                    // Combine and deduplicate
                    const allUnmapped = [...new Set([...unmapped2024, ...unmapped2025])];
                    
                    this.unmappedAccounts = allUnmapped;
                    
                    if (allUnmapped.length > 0) {
                        console.warn(`Found ${allUnmapped.length} unmapped accounts:`, allUnmapped);
                    }

                    return allUnmapped;

                } catch (error) {
                    console.error('Error detecting unmapped accounts:', error);
                    return [];
                }
            }

            // Validate data completeness
            validateData() {
                const errors = [];
                const warnings = [];

                // Check if both periods are loaded
                const factTable2024 = this.dataStore.getFactTable('2024');
                const factTable2025 = this.dataStore.getFactTable('2025');
                
                if (!factTable2024) {
                    errors.push('Trial Balance for 2024 is not loaded');
                }
                if (!factTable2025) {
                    errors.push('Trial Balance for 2025 is not loaded');
                }

                // Hierarchy is now embedded in trial balance files
                // Check if dimension tables are loaded (optional)
                if (!this.dataStore.getDatesTable()) {
                    warnings.push('Dates table is not loaded (optional)');
                }
                if (!this.dataStore.getFormatTable()) {
                    warnings.push('Format table is not loaded (optional)');
                }

                return { errors, warnings, unmappedAccounts: [] };
            }

            // Consolidated statement generation method
            generateStatement(statementType, options = {}) {
                try {
                    const { factTable2024, factTable2025 } = this.validateRequiredData();

                    // Filter for specific statement type
                    const filtered2024 = factTable2024.filter(d => d.statement_type === statementType);
                    const filtered2025 = factTable2025.filter(d => d.statement_type === statementType);

                    // Group by category and subcategory for both periods
                    const grouped2024 = this.groupByPeriod(filtered2024, '2024');
                    const grouped2025 = this.groupByPeriod(filtered2025, '2025');

                    // Add ordering if specified
                    const ordered2024 = options.orderBy ? grouped2024.orderby('category', 'subcategory') : grouped2024;
                    const ordered2025 = options.orderBy ? grouped2025.orderby('category', 'subcategory') : grouped2025;

                    // Join 2024 and 2025 data
                    const combined = ordered2024.join_full(ordered2025, ['category', 'subcategory']);
                    
                    // Calculate variances
                    const withVariances = this.deriveVarianceColumns(combined);

                    // Calculate category totals
                    const categoryTotals = this.calculateCategoryTotals(withVariances);

                    // Build result object
                    const result = {
                        details: withVariances,
                        totals: categoryTotals
                    };

                    // Add statement-specific calculations
                    if (options.calculateMetrics) {
                        result.metrics = options.calculateMetrics(categoryTotals);
                    }

                    if (options.validateBalance) {
                        const validation = options.validateBalance(categoryTotals);
                        Object.assign(result, validation);
                    }

                    return result;

                } catch (error) {
                    const statementName = options.name || 'Statement';
                    console.error(`Error generating ${statementName}:`, error);
                    throw error;
                }
            }

            // Generate Balance Sheet
            generateBalanceSheet() {
                return this.generateStatement(STATEMENT_TYPES.BALANCE_SHEET, {
                    name: 'Balance Sheet',
                    validateBalance: (categoryTotals) => {
                        const totals = categoryTotals.objects();
                        let totalAssets = 0, totalLiabilities = 0, totalEquity = 0;
                        
                        totals.forEach(row => {
                            if (row.category === 'Assets') totalAssets = row.amount_2025;
                            if (row.category === 'Liabilities') totalLiabilities = row.amount_2025;
                            if (row.category === 'Equity') totalEquity = row.amount_2025;
                        });

                        const imbalance = Math.abs(totalAssets - (totalLiabilities + totalEquity));
                        if (imbalance > 0.01) {
                            console.warn(`Balance Sheet imbalance: ${imbalance.toFixed(2)}`);
                        }

                        return {
                            balanced: imbalance <= 0.01,
                            imbalance: imbalance
                        };
                    }
                });
            }

            // Generate Income Statement
            generateIncomeStatement() {
                return this.generateStatement(STATEMENT_TYPES.INCOME_STATEMENT, {
                    name: 'Income Statement',
                    orderBy: true,
                    calculateMetrics: (categoryTotals) => {
                        const totals = categoryTotals.objects();
                        let revenue2024 = 0, revenue2025 = 0;
                        let cogs2024 = 0, cogs2025 = 0;
                        let opex2024 = 0, opex2025 = 0;
                        let otherIncome2024 = 0, otherIncome2025 = 0;
                        let taxes2024 = 0, taxes2025 = 0;

                        totals.forEach(row => {
                            if (row.category === 'Revenue') {
                                revenue2024 = row.amount_2024;
                                revenue2025 = row.amount_2025;
                            } else if (row.category === 'Cost of Goods Sold') {
                                cogs2024 = row.amount_2024;
                                cogs2025 = row.amount_2025;
                            } else if (row.category === 'Operating Expenses') {
                                opex2024 = row.amount_2024;
                                opex2025 = row.amount_2025;
                            } else if (row.category === 'Other Income') {
                                otherIncome2024 = row.amount_2024;
                                otherIncome2025 = row.amount_2025;
                            } else if (row.category === 'Taxes') {
                                taxes2024 = row.amount_2024;
                                taxes2025 = row.amount_2025;
                            }
                        });

                        const grossProfit2024 = revenue2024 - cogs2024;
                        const grossProfit2025 = revenue2025 - cogs2025;
                        const operatingIncome2024 = grossProfit2024 - opex2024;
                        const operatingIncome2025 = grossProfit2025 - opex2025;
                        const netIncome2024 = operatingIncome2024 + otherIncome2024 - taxes2024;
                        const netIncome2025 = operatingIncome2025 + otherIncome2025 - taxes2025;

                        return {
                            grossProfit: { '2024': grossProfit2024, '2025': grossProfit2025 },
                            operatingIncome: { '2024': operatingIncome2024, '2025': operatingIncome2025 },
                            netIncome: { '2024': netIncome2024, '2025': netIncome2025 }
                        };
                    }
                });
            }

            // Generate Cash Flow Statement
            generateCashFlowStatement() {
                return this.generateStatement(STATEMENT_TYPES.CASH_FLOW, {
                    name: 'Cash Flow Statement',
                    orderBy: true,
                    calculateMetrics: (categoryTotals) => {
                        const totals = categoryTotals.objects();
                        let operating2024 = 0, operating2025 = 0;
                        let investing2024 = 0, investing2025 = 0;
                        let financing2024 = 0, financing2025 = 0;

                        totals.forEach(row => {
                            if (row.category === 'Operating Activities') {
                                operating2024 = row.amount_2024;
                                operating2025 = row.amount_2025;
                            } else if (row.category === 'Investing Activities') {
                                investing2024 = row.amount_2024;
                                investing2025 = row.amount_2025;
                            } else if (row.category === 'Financing Activities') {
                                financing2024 = row.amount_2024;
                                financing2025 = row.amount_2025;
                            }
                        });

                        const netChange2024 = operating2024 + investing2024 + financing2024;
                        const netChange2025 = operating2025 + investing2025 + financing2025;

                        return {
                            netChange: {
                                '2024': netChange2024,
                                '2025': netChange2025,
                                variance: netChange2025 - netChange2024
                            }
                        };
                    }
                });
            }

            // Calculate variance between two periods
            calculateVariance(period1, period2) {
                try {
                    const factTable1 = this.dataStore.getFactTable(period1);
                    const factTable2 = this.dataStore.getFactTable(period2);

                    if (!factTable1 || !factTable2) {
                        throw new Error(`Data for periods ${period1} or ${period2} not loaded`);
                    }

                    // Rename amount columns to distinguish periods
                    const table1 = factTable1
                        .select('account_code', 'account_description', 'movement_amount')
                        .rename({ movement_amount: `amount_${period1}` });

                    const table2 = factTable2
                        .select('account_code', 'movement_amount')
                        .rename({ movement_amount: `amount_${period2}` });

                    // Join tables on account_code
                    const joined = table1
                        .join_full(table2, 'account_code')
                        .derive({
                            [`amount_${period1}`]: d => d[`amount_${period1}`] || 0,
                            [`amount_${period2}`]: d => d[`amount_${period2}`] || 0,
                            variance_amount: d => (d[`amount_${period2}`] || 0) - (d[`amount_${period1}`] || 0),
                            variance_percent: d => {
                                const amt1 = d[`amount_${period1}`] || 0;
                                const amt2 = d[`amount_${period2}`] || 0;
                                
                                // Handle division by zero
                                if (amt1 === 0) {
                                    return amt2 === 0 ? 0 : null; // Return null for N/A cases
                                }
                                
                                return ((amt2 - amt1) / Math.abs(amt1)) * 100;
                            }
                        });

                    return joined;

                } catch (error) {
                    console.error('Error calculating variance:', error);
                    throw error;
                }
            }
        }

        // ExportHandler class for Excel export
        class ExportHandler {
            constructor(dataStore) {
                this.dataStore = dataStore;
            }

            // Convert Arquero table to array of arrays
            tableToArrays(table, includeHeaders = true) {
                const data = [];
                
                if (includeHeaders) {
                    data.push(table.columnNames());
                }
                
                table.objects().forEach(row => {
                    const rowArray = table.columnNames().map(col => row[col]);
                    data.push(rowArray);
                });
                
                return data;
            }

            // Export single statement to Excel
            async exportStatement(statementData, statementName) {
                try {
                    const workbook = new ExcelJS.Workbook();
                    const worksheet = workbook.addWorksheet(statementName);

                    // Convert statement data to array format
                    const headers = ['Line Item', '2024', '2025', 'Variance ($)', 'Variance (%)'];
                    const rows = [headers];

                    // Add details
                    const details = statementData.details.objects();
                    let currentCategory = null;

                    details.forEach(row => {
                        if (row.category !== currentCategory) {
                            currentCategory = row.category;
                            rows.push([currentCategory, '', '', '', '']);
                        }
                        rows.push([
                            '  ' + (row.subcategory || row.category),
                            row.amount_2024,
                            row.amount_2025,
                            row.variance_amount,
                            row.variance_percent
                        ]);
                    });

                    // Add empty row
                    rows.push(['', '', '', '', '']);

                    // Add totals
                    rows.push(['Category Totals', '', '', '', '']);
                    const totals = statementData.totals.objects();
                    totals.forEach(row => {
                        rows.push([
                            'Total ' + row.category,
                            row.amount_2024,
                            row.amount_2025,
                            row.variance_amount,
                            row.variance_percent
                        ]);
                    });

                    // Add rows to worksheet
                    rows.forEach((row, index) => {
                        const excelRow = worksheet.addRow(row);
                        
                        // Format header row
                        if (index === 0) {
                            excelRow.font = { bold: true };
                            excelRow.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: 'FF007bff' }
                            };
                            excelRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                        }
                        
                        // Format number columns
                        for (let i = 2; i <= 5; i++) {
                            if (excelRow.getCell(i).value !== '') {
                                excelRow.getCell(i).numFmt = '#,##0.00';
                            }
                        }
                    });

                    // Auto-size columns
                    worksheet.columns.forEach(column => {
                        column.width = 20;
                    });

                    // Generate buffer and download
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${statementName}.xlsx`;
                    link.click();
                    window.URL.revokeObjectURL(url);

                    console.log(`Exported ${statementName} successfully`);

                } catch (error) {
                    console.error('Error exporting statement:', error);
                    throw error;
                }
            }

            // Export all statements to single workbook
            async exportAllStatements(statements) {
                try {
                    const workbook = new ExcelJS.Workbook();

                    // Add each statement as a separate worksheet
                    for (const [name, data] of Object.entries(statements)) {
                        const worksheet = workbook.addWorksheet(name);

                        const headers = ['Line Item', '2024', '2025', 'Variance ($)', 'Variance (%)'];
                        const rows = [headers];

                        // Add details
                        const details = data.details.objects();
                        let currentCategory = null;

                        details.forEach(row => {
                            if (row.category !== currentCategory) {
                                currentCategory = row.category;
                                rows.push([currentCategory, '', '', '', '']);
                            }
                            rows.push([
                                '  ' + (row.subcategory || row.category),
                                row.amount_2024,
                                row.amount_2025,
                                row.variance_amount,
                                row.variance_percent
                            ]);
                        });

                        rows.push(['', '', '', '', '']);
                        rows.push(['Category Totals', '', '', '', '']);
                        
                        const totals = data.totals.objects();
                        totals.forEach(row => {
                            rows.push([
                                'Total ' + row.category,
                                row.amount_2024,
                                row.amount_2025,
                                row.variance_amount,
                                row.variance_percent
                            ]);
                        });

                        // Add rows to worksheet
                        rows.forEach((row, index) => {
                            const excelRow = worksheet.addRow(row);
                            
                            if (index === 0) {
                                excelRow.font = { bold: true };
                                excelRow.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FF007bff' }
                                };
                                excelRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                            }
                            
                            for (let i = 2; i <= 5; i++) {
                                if (excelRow.getCell(i).value !== '') {
                                    excelRow.getCell(i).numFmt = '#,##0.00';
                                }
                            }
                        });

                        worksheet.columns.forEach(column => {
                            column.width = 20;
                        });
                    }

                    // Generate buffer and download
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = config.outputFiles.allStatements;
                    link.click();
                    window.URL.revokeObjectURL(url);

                    console.log('Exported all statements successfully');

                } catch (error) {
                    console.error('Error exporting all statements:', error);
                    throw error;
                }
            }
        }

        // InteractiveUI class for rendering financial statements
        class InteractiveUI {
            constructor() {
                this.currentStatement = null;
                this.sortColumn = null;
                this.sortDirection = 'asc';
            }

            // Format number with thousand separators and 2 decimal places
            formatNumber(value) {
                if (value === null || value === undefined) return 'N/A';
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                }).format(value);
            }

            // Render statement table
            renderStatement(statementData, statementType, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                this.currentStatement = statementData;
                this.currentStatementType = statementType;

                // Create table HTML
                let html = '<table class="financial-table">';
                
                // Table header
                html += '<thead><tr>';
                html += '<th class="col-label">Line Item</th>';
                html += '<th class="col-number sortable" data-col="amount_2024">2024</th>';
                html += '<th class="col-number sortable" data-col="amount_2025">2025</th>';
                html += '<th class="col-number sortable" data-col="variance_amount">Variance ($)</th>';
                html += '<th class="col-number sortable" data-col="variance_percent">Variance (%)</th>';
                html += '</tr></thead>';
                
                html += '<tbody>';

                // Render details grouped by category
                const details = statementData.details.objects();
                const totals = statementData.totals.objects();
                
                let currentCategory = null;
                
                details.forEach(row => {
                    // Add category header if changed
                    if (row.category !== currentCategory) {
                        currentCategory = row.category;
                        html += `<tr class="category-header"><td colspan="5"><strong>${currentCategory}</strong></td></tr>`;
                    }
                    
                    // Add detail row
                    html += '<tr class="detail-row">';
                    html += `<td class="indent">${row.subcategory || row.category}</td>`;
                    html += `<td class="number">${this.formatNumber(row.amount_2024)}</td>`;
                    html += `<td class="number">${this.formatNumber(row.amount_2025)}</td>`;
                    html += `<td class="number ${row.variance_amount >= 0 ? 'positive' : 'negative'}">${this.formatNumber(row.variance_amount)}</td>`;
                    html += `<td class="number ${row.variance_percent >= 0 ? 'positive' : 'negative'}">${this.formatNumber(row.variance_percent)}%</td>`;
                    html += '</tr>';
                });

                // Add category totals
                html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                html += '<tr class="section-header"><td colspan="5"><strong>Category Totals</strong></td></tr>';
                
                totals.forEach(row => {
                    html += '<tr class="subtotal-row">';
                    html += `<td><strong>Total ${row.category}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(row.amount_2024)}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(row.amount_2025)}</strong></td>`;
                    html += `<td class="number ${row.variance_amount >= 0 ? 'positive' : 'negative'}"><strong>${this.formatNumber(row.variance_amount)}</strong></td>`;
                    html += `<td class="number ${row.variance_percent >= 0 ? 'positive' : 'negative'}"><strong>${this.formatNumber(row.variance_percent)}%</strong></td>`;
                    html += '</tr>';
                });

                // Add special metrics for Income Statement
                if (statementType === 'income-statement' && statementData.metrics) {
                    html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                    html += '<tr class="section-header"><td colspan="5"><strong>Key Metrics</strong></td></tr>';
                    
                    const metrics = statementData.metrics;
                    html += '<tr class="metric-row">';
                    html += '<td><strong>Gross Profit</strong></td>';
                    html += `<td class="number"><strong>${this.formatNumber(metrics.grossProfit['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.grossProfit['2025'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.grossProfit['2025'] - metrics.grossProfit['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(((metrics.grossProfit['2025'] - metrics.grossProfit['2024']) / Math.abs(metrics.grossProfit['2024'])) * 100)}%</strong></td>`;
                    html += '</tr>';
                    
                    html += '<tr class="metric-row">';
                    html += '<td><strong>Operating Income</strong></td>';
                    html += `<td class="number"><strong>${this.formatNumber(metrics.operatingIncome['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.operatingIncome['2025'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.operatingIncome['2025'] - metrics.operatingIncome['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(((metrics.operatingIncome['2025'] - metrics.operatingIncome['2024']) / Math.abs(metrics.operatingIncome['2024'])) * 100)}%</strong></td>`;
                    html += '</tr>';
                    
                    html += '<tr class="metric-row">';
                    html += '<td><strong>Net Income</strong></td>';
                    html += `<td class="number"><strong>${this.formatNumber(metrics.netIncome['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.netIncome['2025'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(metrics.netIncome['2025'] - metrics.netIncome['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(((metrics.netIncome['2025'] - metrics.netIncome['2024']) / Math.abs(metrics.netIncome['2024'])) * 100)}%</strong></td>`;
                    html += '</tr>';
                }

                // Add net change for Cash Flow Statement
                if (statementType === 'cash-flow' && statementData.netChange) {
                    html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                    html += '<tr class="total-row">';
                    html += '<td><strong>Net Change in Cash</strong></td>';
                    html += `<td class="number"><strong>${this.formatNumber(statementData.netChange['2024'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(statementData.netChange['2025'])}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber(statementData.netChange.variance)}</strong></td>`;
                    html += `<td class="number"><strong>${this.formatNumber((statementData.netChange.variance / Math.abs(statementData.netChange['2024'])) * 100)}%</strong></td>`;
                    html += '</tr>';
                }

                // Add balance check for Balance Sheet
                if (statementType === 'balance-sheet' && statementData.balanced !== undefined) {
                    html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                    if (statementData.balanced) {
                        html += '<tr class="info-row"><td colspan="5" class="success-message">‚úÖ Balance Sheet is balanced</td></tr>';
                    } else {
                        html += `<tr class="info-row"><td colspan="5" class="warning-message">‚ö†Ô∏è Balance Sheet imbalance: ${this.formatNumber(statementData.imbalance)}</td></tr>`;
                    }
                }

                html += '</tbody></table>';
                
                container.innerHTML = html;
                
                // Enable sorting
                this.enableSorting(container);
                
                // Enable tooltips
                this.enableTooltips(container);
            }

            // Enable sorting on table columns
            enableSorting(container) {
                const sortableHeaders = container.querySelectorAll('th.sortable');
                
                sortableHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const column = header.dataset.col;
                        
                        // Toggle sort direction if same column
                        if (this.sortColumn === column) {
                            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                        } else {
                            this.sortColumn = column;
                            this.sortDirection = 'asc';
                        }
                        
                        // Sort the data
                        const sortedDetails = this.currentStatement.details
                            .orderby(this.sortDirection === 'asc' ? column : aq.desc(column));
                        
                        // Update current statement with sorted data
                        this.currentStatement.details = sortedDetails;
                        
                        // Re-render (we need to pass statement type, so we'll store it)
                        this.renderStatement(this.currentStatement, this.currentStatementType, container.id);
                        
                        // Update header to show sort indicator
                        sortableHeaders.forEach(h => {
                            h.textContent = h.textContent.replace(' ‚ñ≤', '').replace(' ‚ñº', '');
                        });
                        header.textContent += this.sortDirection === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
                    });
                });
            }

            // Enable drill-down on subtotal rows (placeholder for future implementation)
            enableDrillDown(container) {
                // This would expand/collapse detail rows under subtotals
                // Implementation depends on data structure with hierarchical relationships
                console.log('Drill-down feature: To be implemented with hierarchical data');
            }

            // Enable filtering (placeholder for future implementation)
            enableFiltering(container) {
                // This would add filter controls and apply filters to the data
                console.log('Filtering feature: To be implemented');
            }

            // Enable tooltips on amount cells
            enableTooltips(container) {
                const numberCells = container.querySelectorAll('td.number');
                
                numberCells.forEach(cell => {
                    cell.addEventListener('mouseenter', (e) => {
                        this.showTooltip(e.target, {
                            value: cell.textContent,
                            info: 'Hover for details'
                        });
                    });
                    
                    cell.addEventListener('mouseleave', () => {
                        this.hideTooltip();
                    });
                });
            }

            // Show tooltip
            showTooltip(element, data) {
                // Remove existing tooltip
                this.hideTooltip();
                
                // Create tooltip element
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.id = 'financial-tooltip';
                
                // Tooltip content
                tooltip.innerHTML = `
                    <div class="tooltip-content">
                        <strong>Value:</strong> ${data.value}<br>
                        <em>${data.info}</em>
                    </div>
                `;
                
                document.body.appendChild(tooltip);
                
                // Position tooltip near cursor
                const rect = element.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';
            }

            // Hide tooltip
            hideTooltip() {
                const tooltip = document.getElementById('financial-tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.dataStore = new DataStore();
                this.dataLoader = new DataLoader();
                this.statementGenerator = new StatementGenerator(this.dataStore);
                this.interactiveUI = new InteractiveUI();
                this.exportHandler = new ExportHandler(this.dataStore);
                this.currentStatementType = 'balance-sheet';
                this.currentStatementData = null;
            }

            // Update file status indicator
            updateFileStatus(fileId, status, message) {
                const statusElement = document.getElementById(`status-${fileId}`);
                if (statusElement) {
                    if (status === 'success') {
                        statusElement.textContent = message ? `‚úÖ ${message}` : '‚úÖ';
                        statusElement.style.color = '#28a745';
                    } else if (status === 'error') {
                        statusElement.textContent = '‚ùå';
                        statusElement.style.color = '#dc3545';
                    } else if (status === 'loading') {
                        statusElement.textContent = '‚è≥';
                        statusElement.style.color = '#ffc107';
                    }
                }
            }

            // Show loading message
            showLoadingMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = message;
                    loadingStatus.style.color = '#007bff';
                }
            }

            // Show error message
            showErrorMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = '‚ùå ' + message;
                    loadingStatus.style.color = '#dc3545';
                }
            }

            // Show success message
            showSuccessMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = '‚úÖ ' + message;
                    loadingStatus.style.color = '#28a745';
                }
            }

            // Handle input directory selection
            async handleSelectInputDirectory() {
                try {
                    await this.dataLoader.selectInputDirectory();
                    const statusText = document.getElementById('input-dir-status');
                    statusText.textContent = `üìÅ ${this.dataLoader.inputDirHandle.name}`;
                    statusText.style.color = '#28a745';
                    
                    // Enable load button
                    document.getElementById('load-all-files').disabled = false;
                } catch (error) {
                    this.showErrorMessage(error.message);
                }
            }

            // Load all files
            async handleLoadAllFiles() {
                this.showLoadingMessage('Loading trial balance files...');
                
                try {
                    // Step 1: Load trial balance for 2024 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2024 trial balance...');
                    this.updateFileStatus('tb2024', 'loading');
                    const { movements: movements2024, balances: balances2024 } = await this.dataLoader.loadTrialBalance('2024');
                    
                    this.dataStore.setFactTable(movements2024, '2024', 'movements');
                    this.dataStore.setFactTable(balances2024, '2024', 'balances');
                    this.updateFileStatus('tb2024', 'success', `M:${movements2024.numRows()} B:${balances2024.numRows()}`);

                    // Step 2: Load trial balance for 2025 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2025 trial balance...');
                    this.updateFileStatus('tb2025', 'loading');
                    const { movements: movements2025, balances: balances2025 } = await this.dataLoader.loadTrialBalance('2025');
                    
                    this.dataStore.setFactTable(movements2025, '2025', 'movements');
                    this.dataStore.setFactTable(balances2025, '2025', 'balances');
                    this.updateFileStatus('tb2025', 'success', `M:${movements2025.numRows()} B:${balances2025.numRows()}`);
                    
                    // Update combined TB count
                    const combinedCount = movements2024.numRows() + balances2024.numRows() + movements2025.numRows() + balances2025.numRows();
                    this.updateFileStatus('tb2425', 'success', `(${combinedCount} total)`);
                    
                    // Hierarchy is embedded in trial balance data
                    this.updateFileStatus('hierarchy', 'success', '(embedded)');

                    // Get loaded years from DataStore
                    const loadedYears = this.dataStore.getAllPeriods();
                    console.log(`Loaded trial balance years: ${loadedYears.join(', ')}`);

                    // Load Dates (optional) - filtered to loaded years only
                    try {
                        this.updateFileStatus('dates', 'loading');
                        const dates = await this.dataLoader.loadDates(loadedYears);
                        this.dataStore.setDatesTable(dates);
                        this.updateFileStatus('dates', 'success', `(${dates.numRows()}√ó${dates.numCols()})`);
                    } catch (error) {
                        this.updateFileStatus('dates', 'success', '(N/A)');
                        console.log('Dates file not loaded (optional)');
                    }

                    // Load Format (optional)
                    try {
                        this.updateFileStatus('format', 'loading');
                        const format = await this.dataLoader.loadFormat();
                        this.dataStore.setFormatTable(format);
                        this.updateFileStatus('format', 'success', `(${format.numRows()}√ó${format.numCols()})`);
                    } catch (error) {
                        this.updateFileStatus('format', 'success', '(N/A)');
                        console.log('Format file not loaded (optional)');
                    }

                    this.showSuccessMessage('Files loaded');
                    
                    // Validate data and show results
                    this.validateAndDisplayResults();
                    
                    // Show statement section
                    document.getElementById('statement-section').style.display = 'block';
                    
                    // Enable export buttons
                    document.getElementById('export-current').disabled = false;
                    document.getElementById('export-all').disabled = false;
                    
                    // Generate and display default statement (Balance Sheet)
                    this.generateAndDisplayStatement('balance-sheet');

                } catch (error) {
                    this.showErrorMessage(error.message);
                    console.error('File loading error:', error);
                    console.error('Error stack:', error.stack);
                    
                    // Update status indicators to show error
                    this.updateFileStatus('tb2024', 'error');
                    this.updateFileStatus('tb2025', 'error');
                    this.updateFileStatus('hierarchy', 'error');
                }
            }

            // Validate data and display results
            validateAndDisplayResults() {
                const validation = this.statementGenerator.validateData();
                const validationContainer = document.getElementById('validation-messages');
                const errorsContainer = document.getElementById('validation-errors');
                const warningsContainer = document.getElementById('validation-warnings');

                // Clear previous messages
                errorsContainer.innerHTML = '';
                warningsContainer.innerHTML = '';

                // Display Afrondingsverschil replacements
                if (window.afrondingsReplacements && window.afrondingsReplacements.length > 0) {
                    window.afrondingsReplacements.forEach(replacement => {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'validation-warning-item';
                        infoDiv.innerHTML = `‚ÑπÔ∏è <strong>Account replaced:</strong> ${replacement}`;
                        warningsContainer.appendChild(infoDiv);
                    });
                }

                // Display errors
                if (validation.errors.length > 0) {
                    validation.errors.forEach(error => {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'validation-error-item';
                        errorDiv.textContent = '‚ùå ' + error;
                        errorsContainer.appendChild(errorDiv);
                    });
                }

                // Display warnings
                if (validation.warnings.length > 0) {
                    validation.warnings.forEach(warning => {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'validation-warning-item';
                        warningDiv.textContent = '‚ö†Ô∏è ' + warning;
                        warningsContainer.appendChild(warningDiv);
                    });
                }

                // Display unmapped accounts if any
                if (validation.unmappedAccounts.length > 0) {
                    const unmappedDiv = document.createElement('div');
                    unmappedDiv.className = 'validation-warning-item';
                    unmappedDiv.innerHTML = `
                        <strong>Unmapped Accounts (${validation.unmappedAccounts.length}):</strong>
                        <div class="unmapped-accounts-list">
                            ${validation.unmappedAccounts.join(', ')}
                        </div>
                    `;
                    warningsContainer.appendChild(unmappedDiv);
                }

                // Show validation container if there are any messages
                if (validation.errors.length > 0 || validation.warnings.length > 0) {
                    validationContainer.style.display = 'block';
                } else {
                    validationContainer.style.display = 'none';
                }
            }

            // Generate and display statement
            generateAndDisplayStatement(statementType) {
                try {
                    let statementData;
                    
                    switch(statementType) {
                        case 'balance-sheet':
                            statementData = this.statementGenerator.generateBalanceSheet();
                            break;
                        case 'income-statement':
                            statementData = this.statementGenerator.generateIncomeStatement();
                            break;
                        case 'cash-flow':
                            statementData = this.statementGenerator.generateCashFlowStatement();
                            break;
                        default:
                            throw new Error('Unknown statement type');
                    }
                    
                    this.interactiveUI.renderStatement(statementData, statementType, 'statement-display');
                    this.currentStatementType = statementType;
                    this.currentStatementData = statementData;
                    
                } catch (error) {
                    console.error('Error generating statement:', error);
                    const display = document.getElementById('statement-display');
                    if (display) {
                        display.innerHTML = `<div class="error-message">Error generating statement: ${error.message}</div>`;
                    }
                }
            }

            // Handle export current statement
            async handleExportCurrent() {
                if (!this.currentStatementData) {
                    this.showExportStatus('No statement to export', 'error');
                    return;
                }

                try {
                    this.showExportStatus('Exporting...', 'loading');
                    
                    const statementNames = {
                        'balance-sheet': config.outputFiles.balanceSheet.replace('.xlsx', ''),
                        'income-statement': config.outputFiles.incomeStatement.replace('.xlsx', ''),
                        'cash-flow': config.outputFiles.cashFlowStatement.replace('.xlsx', '')
                    };
                    
                    await this.exportHandler.exportStatement(
                        this.currentStatementData, 
                        statementNames[this.currentStatementType]
                    );
                    
                    this.showExportStatus('Export successful!', 'success');
                    
                } catch (error) {
                    this.showExportStatus('Export failed: ' + error.message, 'error');
                    console.error('Export error:', error);
                }
            }

            // Handle export all statements
            async handleExportAll() {
                try {
                    this.showExportStatus('Exporting all statements...', 'loading');
                    
                    const statements = {
                        'Balance Sheet': this.statementGenerator.generateBalanceSheet(),
                        'Income Statement': this.statementGenerator.generateIncomeStatement(),
                        'Cash Flow': this.statementGenerator.generateCashFlowStatement()
                    };
                    
                    await this.exportHandler.exportAllStatements(statements);
                    
                    this.showExportStatus('All statements exported successfully!', 'success');
                    
                } catch (error) {
                    this.showExportStatus('Export failed: ' + error.message, 'error');
                    console.error('Export error:', error);
                }
            }

            // Show export status message
            showExportStatus(message, type) {
                const statusElement = document.getElementById('export-status');
                if (statusElement) {
                    statusElement.textContent = message;
                    
                    if (type === 'success') {
                        statusElement.style.color = '#28a745';
                    } else if (type === 'error') {
                        statusElement.style.color = '#dc3545';
                    } else if (type === 'loading') {
                        statusElement.style.color = '#007bff';
                    }
                    
                    // Clear message after 3 seconds
                    if (type !== 'loading') {
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    }
                }
            }

            // Handle tab switching
            handleTabSwitch(statementType) {
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.statement === statementType) {
                        btn.classList.add('active');
                    }
                });
                
                // Generate and display the selected statement
                this.generateAndDisplayStatement(statementType);
            }

            // Show data preview
            showDataPreview(fileId) {
                let table = null;
                let title = '';
                
                switch(fileId) {
                    case 'tb2024':
                        table = this.dataStore.getMovementsTable('2024');
                        title = 'Trial Balance 2024 Movements - First 20 Rows';
                        break;
                    case 'tb2025':
                        table = this.dataStore.getMovementsTable('2025');
                        title = 'Trial Balance 2025 Movements - First 20 Rows';
                        break;
                    case 'tb24m':
                        table = this.dataStore.getMovementsTable('2024');
                        if (table) {
                            // Sort by account_code and period for readability
                            table = table.orderby('account_code', 'period');
                            const rowCount = table.numRows();
                            title = `TB 2024 Movements - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                    case 'tb24b':
                        table = this.dataStore.getBalancesTable('2024');
                        if (table) {
                            // Sort by account_code and period for readability
                            table = table.orderby('account_code', 'period');
                            const rowCount = table.numRows();
                            title = `TB 2024 Balances - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                    case 'tb25m':
                        table = this.dataStore.getMovementsTable('2025');
                        if (table) {
                            // Sort by account_code and period for readability
                            table = table.orderby('account_code', 'period');
                            const rowCount = table.numRows();
                            title = `TB 2025 Movements - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                    case 'tb25b':
                        table = this.dataStore.getBalancesTable('2025');
                        if (table) {
                            // Sort by account_code and period for readability
                            table = table.orderby('account_code', 'period');
                            const rowCount = table.numRows();
                            title = `TB 2025 Balances - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                    case 'tb2425':
                        // Combine both movements tables
                        const tb2024m = this.dataStore.getMovementsTable('2024');
                        const tb2025m = this.dataStore.getMovementsTable('2025');
                        if (tb2024m && tb2025m) {
                            table = tb2024m.concat(tb2025m);
                            const rowCount = table.numRows();
                            title = `Combined Movements 2024+2025 - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                    case 'hierarchy':
                        table = this.dataStore.getHierarchyTable();
                        title = 'Account Hierarchy - First 20 Rows';
                        break;
                    case 'dates':
                        table = this.dataStore.getDatesTable();
                        title = 'Dates - All Rows';
                        break;
                    case 'format':
                        table = this.dataStore.getFormatTable();
                        title = 'Format - First 20 Rows';
                        break;
                }
                
                if (!table) {
                    return;
                }
                
                const previewDiv = document.getElementById('data-preview');
                const titleDiv = document.getElementById('preview-title');
                const contentDiv = document.getElementById('preview-content');
                
                titleDiv.textContent = title;
                
                // Get first 20 rows
                const rows = table.slice(0, 20).objects();
                const columns = table.columnNames();
                
                // Build table HTML
                let html = '<table><thead><tr>';
                columns.forEach(col => {
                    html += `<th>${col}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                rows.forEach(row => {
                    html += '<tr>';
                    columns.forEach(col => {
                        const value = row[col];
                        const displayValue = value !== null && value !== undefined ? value : '';
                        html += `<td>${displayValue}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                contentDiv.innerHTML = html;
                previewDiv.style.display = 'block';
            }

            // Setup event listeners
            setupEventListeners() {
                document.getElementById('select-input-dir').addEventListener('click', () => {
                    this.handleSelectInputDirectory();
                });

                document.getElementById('load-all-files').addEventListener('click', () => {
                    this.handleLoadAllFiles();
                });

                // Tab switching
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.handleTabSwitch(btn.dataset.statement);
                    });
                });

                // Export buttons
                document.getElementById('export-current').addEventListener('click', () => {
                    this.handleExportCurrent();
                });

                document.getElementById('export-all').addEventListener('click', () => {
                    this.handleExportAll();
                });
                
                // File preview clicks
                document.querySelectorAll('.file-status-item.clickable').forEach(item => {
                    item.addEventListener('click', () => {
                        const fileId = item.dataset.file;
                        this.showDataPreview(fileId);
                    });
                });
                
                // Close preview button
                document.getElementById('close-preview').addEventListener('click', () => {
                    document.getElementById('data-preview').style.display = 'none';
                });
            }
        }

        // Initialize application
        async function init() {
            console.log('Financial Statement Generator initialized');
            console.log('Arquero loaded:', typeof aq !== 'undefined');
            console.log('ExcelJS loaded:', typeof ExcelJS !== 'undefined');
            
            // Check browser compatibility
            if (!window.showDirectoryPicker) {
                alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
                console.error('File System Access API not supported');
            }
            
            // Load configuration
            await loadConfig();
            
            // Initialize UI Controller
            window.uiController = new UIController();
            window.uiController.setupEventListeners();
            
            // Initial state: disable export buttons until data is loaded
            document.getElementById('export-current').disabled = true;
            document.getElementById('export-all').disabled = true;
            
            console.log('Application ready');
            console.log('Configuration:', config);
        }

        // Run initialization when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
