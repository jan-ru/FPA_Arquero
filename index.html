<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statement Generator</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/arquero@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/exceljs@latest/dist/exceljs.min.js"></script>
    
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-size: 13px;
        }

        #app {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .section {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            transition: box-shadow 0.3s ease;
        }

        .section:hover {
            box-shadow: 0 10px 15px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.1);
        }

        h2 {
            margin-bottom: 12px;
            color: #2d3748;
            font-size: 1.1em;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 6px;
        }

        .directory-selection {
            margin-bottom: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-right: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(245, 87, 108, 0.4);
        }

        .btn:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .status-text {
            color: #666;
            font-size: 12px;
        }

        .file-loading {
            margin-bottom: 12px;
        }

        .loading-status {
            margin-top: 8px;
            min-height: 18px;
            color: #666;
            font-size: 12px;
        }

        .file-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .file-status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 4px;
            border-left: 3px solid #667eea;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .file-status-item.clickable {
            cursor: pointer;
        }

        .file-status-item.clickable:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }

        .file-status-item.clickable.loaded {
            cursor: pointer;
        }

        .file-status-item:not(.clickable):hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        #data-preview th {
            background-color: #667eea;
            color: white;
            padding: 6px 8px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        #data-preview td {
            padding: 4px 8px;
            border-bottom: 1px solid #e9ecef;
        }

        #data-preview tr:hover {
            background-color: #f8f9fa;
        }

        .file-label {
            font-weight: 600;
            color: #2d3748;
        }

        .status-indicator {
            font-size: 12px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 3px;
        }

        .tab-btn {
            padding: 8px 16px;
            border: none;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: 4px 4px 0 0;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            color: #4a5568;
        }

        .tab-btn:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            transform: translateY(-1px);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-color: #667eea;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .statement-display {
            min-height: 400px;
            overflow-x: auto;
        }

        .financial-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .financial-table th {
            background-color: #007bff;
            color: white;
            padding: 8px 6px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        .financial-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .financial-table th.sortable:hover {
            background-color: #0056b3;
        }

        .financial-table th.col-number {
            text-align: right;
        }

        .financial-table td {
            padding: 6px;
            border-bottom: 1px solid #e9ecef;
        }

        .financial-table td.number {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .financial-table td.indent {
            padding-left: 24px;
        }

        .financial-table tr.detail-row:hover {
            background-color: #f8f9fa;
        }

        .financial-table tr.category-header td {
            background-color: #e9ecef;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #007bff;
        }

        .financial-table tr.subtotal-row td {
            background-color: #f8f9fa;
            border-top: 2px solid #333;
            border-bottom: 2px solid #333;
            padding: 8px 6px;
        }

        .financial-table tr.total-row td {
            background-color: #e7f3ff;
            border-top: 3px double #007bff;
            border-bottom: 3px double #007bff;
            padding: 8px 6px;
            font-size: 13px;
        }

        .financial-table tr.metric-row td {
            background-color: #fff3cd;
            padding: 8px 6px;
        }

        .financial-table tr.section-header td {
            background-color: #d1ecf1;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #0c5460;
        }

        .financial-table tr.spacer-row td {
            padding: 3px;
            border: none;
        }

        .financial-table tr.info-row td {
            padding: 8px 6px;
            text-align: center;
            font-weight: 500;
        }

        .financial-table .positive {
            color: #28a745;
        }

        .financial-table .negative {
            color: #dc3545;
        }

        .success-message {
            color: #28a745;
            background-color: #d4edda;
        }

        .warning-message {
            color: #856404;
            background-color: #fff3cd;
        }

        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .tooltip-content {
            line-height: 1.5;
        }

        .export-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .validation-messages {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            font-size: 12px;
        }

        .validation-errors {
            margin-bottom: 8px;
        }

        .validation-errors:empty {
            display: none;
        }

        .validation-warnings:empty {
            display: none;
        }

        .validation-error-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #f8d7da;
            color: #721c24;
            border-left: 3px solid #dc3545;
            border-radius: 3px;
        }

        .validation-warning-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #fff3cd;
            color: #856404;
            border-left: 3px solid #ffc107;
            border-radius: 3px;
        }

        .unmapped-accounts-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 5px;
            padding: 8px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Statement Generator <span style="font-size: 0.6em; color: rgba(255,255,255,0.8);">v2.1.0</span></h1>
        
        <!-- File Upload Section -->
        <div id="file-upload-section" class="section">
            <h2>Data Files</h2>
            
            <div class="directory-selection">
                <button id="select-input-dir" class="btn btn-primary">Select Directory</button>
                <button id="load-all-files" class="btn btn-secondary" disabled>Load Files</button>
                <span id="input-dir-status" class="status-text"></span>
                <div id="loading-status" class="loading-status"></div>
            </div>
            
            <div class="file-status-grid">
                <div class="file-status-item clickable" data-file="tb2024">
                    <span class="file-label">TB 2024</span>
                    <span id="status-tb2024" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="tb2025">
                    <span class="file-label">TB 2025</span>
                    <span id="status-tb2025" class="status-indicator">‚ö™</span>
                </div>
                <div class="file-status-item clickable" data-file="tb2425">
                    <span class="file-label">TB 2024+2025</span>
                    <span id="status-tb2425" class="status-indicator">üëÅÔ∏è</span>
                </div>
            </div>
            
            <!-- Data Preview Section -->
            <div id="data-preview" style="display: none; margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 4px; max-height: 400px; overflow: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong id="preview-title" style="font-size: 13px;"></strong>
                    <button id="close-preview" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #666;">√ó</button>
                </div>
                <div id="preview-content"></div>
            </div>

            <!-- Validation Messages -->
            <div id="validation-messages" class="validation-messages" style="display: none;">
                <div id="validation-errors" class="validation-errors"></div>
                <div id="validation-warnings" class="validation-warnings"></div>
            </div>
        </div>

        <!-- Statement Display Section -->
        <div id="statement-section" class="section" style="display: none;">
            <h2>Statements</h2>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div id="statement-tabs" class="tabs" style="margin-bottom: 0;">
                    <button class="tab-btn active" data-statement="balance-sheet">Balance Sheet</button>
                    <button class="tab-btn" data-statement="income-statement">Income Statement</button>
                    <button class="tab-btn" data-statement="cash-flow">Cash Flow</button>
                </div>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <label style="font-size: 13px; color: #4a5568;">
                        Period 2024:
                        <select id="period-2024" style="margin-left: 5px; padding: 4px; border-radius: 4px; border: 1px solid #ccc;">
                            <option value="all">All Periods</option>
                            <option value="1">Period 1</option>
                            <option value="2">Period 2</option>
                            <option value="3">Period 3</option>
                            <option value="4">Period 4</option>
                            <option value="5">Period 5</option>
                            <option value="6">Period 6</option>
                            <option value="7">Period 7</option>
                            <option value="8">Period 8</option>
                            <option value="9">Period 9</option>
                            <option value="10">Period 10</option>
                            <option value="11">Period 11</option>
                            <option value="12">Period 12</option>
                        </select>
                    </label>
                    <label style="font-size: 13px; color: #4a5568;">
                        Period 2025:
                        <select id="period-2025" style="margin-left: 5px; padding: 4px; border-radius: 4px; border: 1px solid #ccc;">
                            <option value="all">All Periods</option>
                            <option value="1">Period 1</option>
                            <option value="2">Period 2</option>
                            <option value="3">Period 3</option>
                            <option value="4">Period 4</option>
                            <option value="5">Period 5</option>
                            <option value="6">Period 6</option>
                            <option value="7">Period 7</option>
                            <option value="8">Period 8</option>
                            <option value="9">Period 9</option>
                            <option value="10">Period 10</option>
                            <option value="11">Period 11</option>
                            <option value="12">Period 12</option>
                        </select>
                    </label>
                    <label style="font-size: 13px; color: #4a5568;">
                        <input type="checkbox" id="show-variance" checked style="margin-right: 5px;">
                        Show Variance
                    </label>
                    <label style="font-size: 13px; color: #4a5568;">
                        <input type="checkbox" id="show-category-totals" checked style="margin-right: 5px;">
                        Show Category Totals
                    </label>
                </div>
            </div>
            <div id="statement-display" class="statement-display"></div>
            
            <!-- Export Controls -->
            <div class="export-controls">
                <button id="export-all" class="btn btn-secondary">Export All</button>
                <span id="export-status" class="status-text"></span>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const STATEMENT_TYPES = {
            BALANCE_SHEET: 'BS',
            INCOME_STATEMENT: 'IS',
            CASH_FLOW: 'CF'
        };

        const EXCEL_COLUMNS = {
            STATEMENT_TYPE: 4,
            LEVEL1_CODE: 5,
            LEVEL1_LABEL: 6,
            LEVEL2_CODE: 7,
            LEVEL2_LABEL: 8,
            LEVEL3_CODE: 9,
            LEVEL3_LABEL: 10,
            ACCOUNT_CODE: 11,
            ACCOUNT_DESCRIPTION: 12
        };

        // Configuration
        let config = null;

        // DataStore class for state management (Singleton pattern)
        class DataStore {
            constructor() {
                if (DataStore.instance) {
                    return DataStore.instance;
                }
                
                this.factTables = {}; // Store FactTables by period and type: {2024: {movements: table, balances: table}, 2025: {...}}
                this.combinedMovements = null; // Combined movements table for both years
                
                DataStore.instance = this;
            }

            // Store FactTable for a specific period and type
            setFactTable(table, period, type = 'movements') {
                if (!this.factTables[period]) {
                    this.factTables[period] = {};
                }
                this.factTables[period][type] = table;
                console.log(`FactTable ${type} for ${period} stored (${table.numRows()} rows)`);
            }

            // Retrieve FactTable for a specific period and type
            getFactTable(period, type = 'movements') {
                return this.factTables[period]?.[type] || null;
            }

            // Shorthand: Get movements table for a period
            getMovementsTable(period) {
                return this.getFactTable(period, 'movements');
            }

            // Shorthand: Get balances table for a period
            getBalancesTable(period) {
                return this.getFactTable(period, 'balances');
            }

            // Get row counts for verification
            getRowCounts(period) {
                const movements = this.getMovementsTable(period);
                const balances = this.getBalancesTable(period);
                return {
                    movements: movements ? movements.numRows() : 0,
                    balances: balances ? balances.numRows() : 0
                };
            }

            // Store Hierarchy Table
            setHierarchyTable(table) {
                this.hierarchyTable = table;
                console.log('Hierarchy Table stored');
            }

            // Retrieve Hierarchy Table
            getHierarchyTable() {
                return this.hierarchyTable;
            }



            // Get all loaded periods
            getAllPeriods() {
                return Object.keys(this.factTables);
            }

            // Store combined movements table
            setCombinedMovements(table) {
                this.combinedMovements = table;
                console.log(`Combined movements table stored (${table.numRows()} rows)`);
            }

            // Retrieve combined movements table
            getCombinedMovements() {
                return this.combinedMovements;
            }

            // Check if all required data is loaded
            isDataComplete() {
                const has2024Movements = this.factTables['2024']?.movements;
                const has2024Balances = this.factTables['2024']?.balances;
                const has2025Movements = this.factTables['2025']?.movements;
                const has2025Balances = this.factTables['2025']?.balances;
                const hasBothPeriods = has2024Movements && has2024Balances && has2025Movements && has2025Balances;
                return hasBothPeriods && this.combinedMovements;
            }

            // Clear all data
            clear() {
                this.factTables = {};
                this.combinedMovements = null;
                console.log('DataStore cleared');
            }
        }
        
        // Load configuration file
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                config = await response.json();
                console.log('Configuration loaded:', config);
                return config;
            } catch (error) {
                console.error('Error loading config:', error);
                // Use default configuration
                config = {
                    inputFiles: {
                        trialBalance2024: "2024_BalansenWinstverliesperperiode.xlsx",
                        trialBalance2025: "2025_BalansenWinstverliesperperiode.xlsx",
                        dates: "DimDates.xlsx",
                        format: "format.xlsx"
                    },
                    outputFiles: {
                        balanceSheet: "balance_sheet.xlsx",
                        incomeStatement: "income_statement.xlsx",
                        cashFlowStatement: "cash_flow_statement.xlsx",
                        allStatements: "financial_statements_all.xlsx"
                    },
                    directories: {
                        input: "input",
                        output: "output"
                    }
                };
                return config;
            }
        }

        // DataLoader class for Excel file parsing with directory access
        class DataLoader {
            constructor() {
                this.inputDirHandle = null;
                this.outputDirHandle = null;
                
                // Dutch month names to period numbers mapping
                this.MONTH_MAP = {
                    'januari': 1,
                    'februari': 2,
                    'maart': 3,
                    'april': 4,
                    'mei': 5,
                    'juni': 6,
                    'juli': 7,
                    'augustus': 8,
                    'september': 9,
                    'oktober': 10,
                    'november': 11,
                    'december': 12
                };
            }

            // Request access to input directory
            async selectInputDirectory() {
                try {
                    // Note: The File System Access API doesn't support relative paths or specific subdirectories
                    // as starting points. We can only use well-known directories like 'documents', 'desktop', etc.
                    // The user will need to navigate to the 'input' directory manually.
                    this.inputDirHandle = await window.showDirectoryPicker({
                        mode: 'read',
                        startIn: 'documents',
                        id: 'financial-statement-input' // Helps browser remember the last location
                    });
                    console.log('Input directory selected:', this.inputDirHandle.name);
                    
                    // Provide helpful feedback if user didn't select 'input' directory
                    if (this.inputDirHandle.name.toLowerCase() !== 'input') {
                        console.warn('Note: Expected directory name is "input". Selected:', this.inputDirHandle.name);
                    }
                    
                    return this.inputDirHandle;
                } catch (error) {
                    console.error('Error selecting input directory:', error);
                    throw new Error('Failed to select input directory');
                }
            }

            // Request access to output directory
            async selectOutputDirectory() {
                try {
                    this.outputDirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });
                    console.log('Output directory selected:', this.outputDirHandle.name);
                    return this.outputDirHandle;
                } catch (error) {
                    console.error('Error selecting output directory:', error);
                    throw new Error('Failed to select output directory');
                }
            }

            // Read file from input directory
            async readFileFromDirectory(filename) {
                if (!this.inputDirHandle) {
                    throw new Error('Input directory not selected. Please select input directory first.');
                }

                try {
                    const fileHandle = await this.inputDirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    return file;
                } catch (error) {
                    console.error(`Error reading file ${filename}:`, error);
                    throw new Error(`File not found: ${filename}`);
                }
            }

            // Validate required columns in Excel data
            validateColumns(data, requiredColumns) {
                if (!data || data.length === 0) {
                    throw new Error('File is empty or invalid');
                }

                const firstRow = data[0];
                const actualColumns = Object.keys(firstRow);
                const missingColumns = requiredColumns.filter(col => !actualColumns.includes(col));

                if (missingColumns.length > 0) {
                    throw new Error(`File missing required columns: ${missingColumns.join(', ')}`);
                }

                return true;
            }

            // Map month name and year to period number
            mapMonthToPeriod(columnName, year) {
                const lowerCol = String(columnName).toLowerCase();
                
                // Check for "Voorafgaandejournaalposten" - map to period 12 (December)
                if (lowerCol.includes('voorafgaandejournaalposten') || lowerCol.includes('voorafgaande')) {
                    if (lowerCol.includes(year)) {
                        return {
                            period: 12,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for month patterns (e.g., "januari2024", "februari2024")
                for (const [monthName, periodNum] of Object.entries(this.MONTH_MAP)) {
                    if (lowerCol.includes(monthName) && lowerCol.includes(year)) {
                        return {
                            period: periodNum,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for balance indicators
                if (lowerCol.includes('saldo') || lowerCol.includes('balance')) {
                    return {
                        period: 12, // End of year
                        year: parseInt(year),
                        type: 'balance'
                    };
                }
                
                return null;
            }

            // Identify period columns from headers
            identifyPeriodColumns(headers, year) {
                const movements = [];
                const balances = [];
                
                headers.forEach((header, index) => {
                    if (!header) return;
                    
                    const mapping = this.mapMonthToPeriod(header, year);
                    if (mapping) {
                        if (mapping.type === 'movement') {
                            movements.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        } else if (mapping.type === 'balance') {
                            balances.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        }
                    }
                });
                
                return { movements, balances };
            }

            // Transform wide format data to long format
            transformWideToLong(worksheet, year) {
                const movements = [];
                const balances = [];
                
                // Get headers from first row
                const headers = [];
                const headerRow = worksheet.getRow(1);
                headerRow.eachCell((cell, colNumber) => {
                    headers[colNumber] = cell.value;
                });
                
                // Identify period columns
                const periodColumns = this.identifyPeriodColumns(headers, year);
                
                console.log(`Found ${periodColumns.movements.length} movement columns and ${periodColumns.balances.length} balance columns for ${year}`);
                
                // Process each data row
                worksheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // Skip header row
                    
                    const accountCode = row.getCell(EXCEL_COLUMNS.ACCOUNT_CODE).value;
                    const accountDescription = row.getCell(EXCEL_COLUMNS.ACCOUNT_DESCRIPTION).value;
                    
                    if (!accountCode) return;
                    
                    // Extract hierarchy columns
                    const statementType = row.getCell(EXCEL_COLUMNS.STATEMENT_TYPE).value;
                    const level1Code = row.getCell(EXCEL_COLUMNS.LEVEL1_CODE).value;
                    const level1Label = row.getCell(EXCEL_COLUMNS.LEVEL1_LABEL).value;
                    const level2Code = row.getCell(EXCEL_COLUMNS.LEVEL2_CODE).value;
                    const level2Label = row.getCell(EXCEL_COLUMNS.LEVEL2_LABEL).value;
                    const level3Code = row.getCell(EXCEL_COLUMNS.LEVEL3_CODE).value;
                    const level3Label = row.getCell(EXCEL_COLUMNS.LEVEL3_LABEL).value;
                    
                    // Determine statement type
                    let stmtType = STATEMENT_TYPES.INCOME_STATEMENT; // Default
                    if (statementType === 'Balans') {
                        stmtType = STATEMENT_TYPES.BALANCE_SHEET;
                    } else if (statementType === 'Winst & verlies') {
                        stmtType = STATEMENT_TYPES.INCOME_STATEMENT;
                    }
                    
                    // Create base row with hierarchy
                    const baseRow = {
                        account_code: String(accountCode),
                        account_description: String(accountDescription ?? ''),
                        statement_type: stmtType,
                        level1_code: level1Code !== null && level1Code !== undefined ? String(level1Code) : '',
                        level1_label: level1Label ?? '',
                        level2_code: level2Code !== null && level2Code !== undefined ? String(level2Code) : '',
                        level2_label: level2Label ?? '',
                        level3_code: level3Code !== null && level3Code !== undefined ? String(level3Code) : '',
                        level3_label: level3Label ?? '',
                        category: (level1Label ?? '').toString(),
                        subcategory: (level2Label ?? level1Label ?? '').toString()
                    };
                    
                    // Process movement columns
                    periodColumns.movements.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            movements.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                movement_amount: Number(value)
                            });
                        }
                    });
                    
                    // Process balance columns
                    periodColumns.balances.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            balances.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                balance_amount: Number(value)
                            });
                        }
                    });
                });
                
                console.log(`Transformed to ${movements.length} movement rows and ${balances.length} balance rows`);
                
                return { movements, balances };
            }

            // Load trial balance amounts for a specific period
            async loadTrialBalance(period) {
                const filename = period === '2024' 
                    ? config.inputFiles.trialBalance2024 
                    : config.inputFiles.trialBalance2025;

                try {
                    const file = await this.readFileFromDirectory(filename);
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    const worksheet = workbook.worksheets[0];
                    
                    console.log(`Transforming ${filename} from wide to long format...`);
                    
                    // Transform wide format to long format
                    const { movements, balances } = this.transformWideToLong(worksheet, period);
                    
                    // Convert arrays to Arquero tables
                    const movementsTable = aq.from(movements);
                    const balancesTable = aq.from(balances);
                    
                    console.log(`Trial Balance ${period} loaded:`);
                    console.log(`  - Movements: ${movementsTable.numRows()} rows`);
                    console.log(`  - Balances: ${balancesTable.numRows()} rows`);
                    
                    return {
                        movements: movementsTable,
                        balances: balancesTable
                    };

                } catch (error) {
                    console.error(`Error loading trial balance for ${period}:`, error);
                    throw error;
                }
            }


        }

        // StatementGenerator class for generating financial statements
        class StatementGenerator {
            constructor(dataStore) {
                this.dataStore = dataStore;
                this.unmappedAccounts = [];
            }

            // Helper: Calculate variance percentage
            calculateVariancePercent(amt2024, amt2025) {
                return amt2024 !== 0 ? ((amt2025 - amt2024) / Math.abs(amt2024)) * 100 : 0;
            }

            // Helper: Validate required data is loaded
            validateRequiredData() {
                const combinedMovements = this.dataStore.getCombinedMovements();
                
                if (!combinedMovements) {
                    throw new Error('Required data not loaded');
                }
                
                return combinedMovements;
            }

            // Helper: Calculate variance columns
            deriveVarianceColumns(combined) {
                return combined.derive({
                    amount_2024: d => d.amount_2024 || 0,
                    amount_2025: d => d.amount_2025 || 0,
                    variance_amount: d => (d.amount_2025 || 0) - (d.amount_2024 || 0),
                    variance_percent: d => {
                        const amt2024 = d.amount_2024 || 0;
                        const amt2025 = d.amount_2025 || 0;
                        return amt2024 !== 0 ? ((amt2025 - amt2024) / Math.abs(amt2024)) * 100 : 0;
                    }
                });
            }

            // Helper: Calculate category totals
            calculateCategoryTotals(combined) {
                return combined
                    .groupby('category')
                    .rollup({
                        amount_2024: d => aq.op.sum(d.amount_2024),
                        amount_2025: d => aq.op.sum(d.amount_2025),
                        variance_amount: d => aq.op.sum(d.variance_amount),
                        variance_percent: d => {
                            const total2024 = aq.op.sum(d.amount_2024);
                            const total2025 = aq.op.sum(d.amount_2025);
                            return total2024 !== 0 ? ((total2025 - total2024) / Math.abs(total2024)) * 100 : 0;
                        }
                    });
            }

            // Detect unmapped accounts
            detectUnmappedAccounts() {
                try {
                    const factTable2024 = this.dataStore.getFactTable('2024');
                    const factTable2025 = this.dataStore.getFactTable('2025');
                    const hierarchyTable = this.dataStore.getHierarchyTable();

                    if (!factTable2024 || !factTable2025 || !hierarchyTable) {
                        return [];
                    }

                    // Get all account codes from hierarchy
                    const hierarchyAccounts = new Set(
                        hierarchyTable.array('account_code')
                    );

                    // Check 2024 accounts
                    const accounts2024 = factTable2024.array('account_code');
                    const unmapped2024 = accounts2024.filter(code => !hierarchyAccounts.has(code));

                    // Check 2025 accounts
                    const accounts2025 = factTable2025.array('account_code');
                    const unmapped2025 = accounts2025.filter(code => !hierarchyAccounts.has(code));

                    // Combine and deduplicate
                    const allUnmapped = [...new Set([...unmapped2024, ...unmapped2025])];
                    
                    this.unmappedAccounts = allUnmapped;
                    
                    if (allUnmapped.length > 0) {
                        console.warn(`Found ${allUnmapped.length} unmapped accounts:`, allUnmapped);
                    }

                    return allUnmapped;

                } catch (error) {
                    console.error('Error detecting unmapped accounts:', error);
                    return [];
                }
            }

            // Validate data completeness
            validateData() {
                const errors = [];
                const warnings = [];

                // Check if combined movements table is loaded
                const combinedMovements = this.dataStore.getCombinedMovements();
                
                if (!combinedMovements) {
                    errors.push('Trial Balance data is not loaded');
                }



                return { errors, warnings, unmappedAccounts: [] };
            }

            // Consolidated statement generation method
            generateStatement(statementType, options = {}) {
                try {
                    const combinedMovements = this.validateRequiredData();

                    // Filter for specific statement type
                    let filtered = combinedMovements.params({ statementType }).filter(d => d.statement_type === statementType);

                    // Apply period filters if specified
                    const period2024Value = options.period2024 || 'all';
                    const period2025Value = options.period2025 || 'all';
                    
                    if (period2024Value !== 'all' || period2025Value !== 'all') {
                        const p2024 = period2024Value === 'all' ? 999 : parseInt(period2024Value);
                        const p2025 = period2025Value === 'all' ? 999 : parseInt(period2025Value);
                        
                        filtered = filtered
                            .params({ period2024: p2024, period2025: p2025 })
                            .filter(d => (d.year === 2024 && d.period <= period2024) || (d.year === 2025 && d.period <= period2025));
                    }

                    // Use conditional aggregation to get both years in one pass (no join needed!)
                    // Include level codes for proper sorting
                    // For Income Statement, flip the sign to show revenue as positive
                    const signMultiplier = statementType === STATEMENT_TYPES.INCOME_STATEMENT ? -1 : 1;
                    const aggregated = filtered
                        .params({ year2024: 2024, year2025: 2025, signMult: signMultiplier })
                        .groupby('category', 'subcategory', 'level1_code', 'level2_code')
                        .rollup({
                            amount_2024: d => aq.op.sum(d.year === year2024 ? d.movement_amount * signMult : 0),
                            amount_2025: d => aq.op.sum(d.year === year2025 ? d.movement_amount * signMult : 0)
                        });

                    console.log('Columns after aggregation:', aggregated.columnNames());

                    // Add ordering if specified - sort by level codes for proper order
                    const ordered = options.orderBy ? aggregated.orderby('level1_code', 'level2_code') : aggregated;
                    
                    // Calculate variances
                    const withVariances = this.deriveVarianceColumns(ordered);

                    // Calculate category totals
                    const categoryTotals = this.calculateCategoryTotals(withVariances);

                    // Build result object
                    const result = {
                        details: withVariances,
                        totals: categoryTotals
                    };

                    // Add statement-specific calculations
                    if (options.calculateMetrics) {
                        result.metrics = options.calculateMetrics(categoryTotals);
                    }

                    if (options.validateBalance) {
                        const validation = options.validateBalance(categoryTotals);
                        Object.assign(result, validation);
                    }

                    return result;

                } catch (error) {
                    const statementName = options.name || 'Statement';
                    console.error(`Error generating ${statementName}:`, error);
                    throw error;
                }
            }

            // Generate Balance Sheet
            generateBalanceSheet(options = {}) {
                return this.generateStatement(STATEMENT_TYPES.BALANCE_SHEET, {
                    name: 'Balance Sheet',
                    period2024: options.period2024,
                    period2025: options.period2025,
                    validateBalance: (categoryTotals) => {
                        const totals = categoryTotals.objects();
                        let totalAssets = 0, totalLiabilities = 0, totalEquity = 0;
                        
                        totals.forEach(row => {
                            if (row.category === 'Assets') totalAssets = row.amount_2025;
                            if (row.category === 'Liabilities') totalLiabilities = row.amount_2025;
                            if (row.category === 'Equity') totalEquity = row.amount_2025;
                        });

                        const imbalance = Math.abs(totalAssets - (totalLiabilities + totalEquity));
                        if (imbalance > 0.01) {
                            console.warn(`Balance Sheet imbalance: ${imbalance.toFixed(2)}`);
                        }

                        return {
                            balanced: imbalance <= 0.01,
                            imbalance: imbalance
                        };
                    }
                });
            }

            // Generate Income Statement
            generateIncomeStatement(options = {}) {
                return this.generateStatement(STATEMENT_TYPES.INCOME_STATEMENT, {
                    name: 'Income Statement',
                    orderBy: true,
                    period2024: options.period2024,
                    period2025: options.period2025,
                    calculateMetrics: (categoryTotals) => {
                        const totals = categoryTotals.objects();
                        let revenue2024 = 0, revenue2025 = 0;
                        let cogs2024 = 0, cogs2025 = 0;
                        let opex2024 = 0, opex2025 = 0;
                        let otherIncome2024 = 0, otherIncome2025 = 0;
                        let taxes2024 = 0, taxes2025 = 0;

                        totals.forEach(row => {
                            const categoryLower = row.category.toLowerCase();
                            
                            // Revenue (Netto-omzet, Omzet, etc.)
                            if (categoryLower.includes('omzet') && !categoryLower.includes('kostprijs')) {
                                revenue2024 += row.amount_2024 || 0;
                                revenue2025 += row.amount_2025 || 0;
                            } 
                            // Cost of Goods Sold (Kostprijs van de omzet)
                            else if (categoryLower.includes('kostprijs')) {
                                cogs2024 += row.amount_2024 || 0;
                                cogs2025 += row.amount_2025 || 0;
                            } 
                            // Operating Expenses (Bedrijfskosten, Kosten, etc.)
                            else if (categoryLower.includes('kosten') || categoryLower.includes('bedrijf')) {
                                opex2024 += row.amount_2024 || 0;
                                opex2025 += row.amount_2025 || 0;
                            } 
                            // Other Income (Overige opbrengsten, etc.)
                            else if (categoryLower.includes('overige') || categoryLower.includes('opbrengst')) {
                                otherIncome2024 += row.amount_2024 || 0;
                                otherIncome2025 += row.amount_2025 || 0;
                            } 
                            // Taxes (Belastingen)
                            else if (categoryLower.includes('belasting') || categoryLower.includes('tax')) {
                                taxes2024 += row.amount_2024 || 0;
                                taxes2025 += row.amount_2025 || 0;
                            }
                        });

                        const grossProfit2024 = revenue2024 + cogs2024;
                        const grossProfit2025 = revenue2025 + cogs2025;
                        const operatingIncome2024 = grossProfit2024 - opex2024;
                        const operatingIncome2025 = grossProfit2025 - opex2025;
                        const netIncome2024 = operatingIncome2024 + otherIncome2024 - taxes2024;
                        const netIncome2025 = operatingIncome2025 + otherIncome2025 - taxes2025;

                        return {
                            grossProfit: { '2024': grossProfit2024, '2025': grossProfit2025 },
                            operatingIncome: { '2024': operatingIncome2024, '2025': operatingIncome2025 },
                            netIncome: { '2024': netIncome2024, '2025': netIncome2025 }
                        };
                    }
                });
            }

            // Generate Cash Flow Statement (Indirect Method - Calculated from Balance Sheet and Income Statement)
            generateCashFlowStatement(options = {}) {
                try {
                    // Get Income Statement to extract Net Income
                    const incomeStatement = this.generateIncomeStatement(options);
                    const incomeDetails = incomeStatement.details.objects();
                    
                    // Get Balance Sheet to calculate changes in working capital
                    const balanceSheet = this.generateBalanceSheet(options);
                    const balanceDetails = balanceSheet.details.objects();
                    
                    // Get Net Income from Income Statement metrics (to ensure consistency)
                    const netIncome2024 = incomeStatement.metrics.netIncome['2024'];
                    const netIncome2025 = incomeStatement.metrics.netIncome['2025'];
                    
                    // Calculate changes in Balance Sheet items (working capital changes)
                    const cashFlowData = [];
                    
                    // Operating Activities
                    cashFlowData.push({
                        category: 'Operating Activities',
                        subcategory: 'Net Income',
                        amount_2024: netIncome2024,
                        amount_2025: netIncome2025
                    });
                    
                    // Add back non-cash expenses (depreciation, amortization)
                    balanceDetails.forEach(row => {
                        if (row.subcategory && (
                            row.subcategory.toLowerCase().includes('afschrijving') ||
                            row.subcategory.toLowerCase().includes('depreciation') ||
                            row.subcategory.toLowerCase().includes('amortization')
                        )) {
                            cashFlowData.push({
                                category: 'Operating Activities',
                                subcategory: row.subcategory,
                                amount_2024: Math.abs(row.variance_amount || 0),
                                amount_2025: Math.abs(row.variance_amount || 0)
                            });
                        }
                    });
                    
                    // Changes in working capital (current assets and liabilities)
                    balanceDetails.forEach(row => {
                        if (row.category && (
                            row.category.toLowerCase().includes('vlottende') ||
                            row.category.toLowerCase().includes('current')
                        )) {
                            const change = (row.amount_2025 || 0) - (row.amount_2024 || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Operating Activities',
                                    subcategory: `Change in ${row.subcategory}`,
                                    amount_2024: 0,
                                    amount_2025: -change // Negative because increase in assets uses cash
                                });
                            }
                        }
                    });
                    
                    // Investing Activities (changes in fixed assets)
                    balanceDetails.forEach(row => {
                        if (row.category && (
                            row.category.toLowerCase().includes('vaste activa') ||
                            row.category.toLowerCase().includes('fixed assets')
                        )) {
                            const change = (row.amount_2025 || 0) - (row.amount_2024 || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Investing Activities',
                                    subcategory: row.subcategory,
                                    amount_2024: 0,
                                    amount_2025: -change
                                });
                            }
                        }
                    });
                    
                    // Financing Activities (changes in equity and long-term liabilities)
                    balanceDetails.forEach(row => {
                        if (row.category && (
                            row.category.toLowerCase().includes('eigen vermogen') ||
                            row.category.toLowerCase().includes('equity') ||
                            row.category.toLowerCase().includes('langlopend') ||
                            row.category.toLowerCase().includes('long-term')
                        )) {
                            const change = (row.amount_2025 || 0) - (row.amount_2024 || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Financing Activities',
                                    subcategory: row.subcategory,
                                    amount_2024: 0,
                                    amount_2025: change
                                });
                            }
                        }
                    });
                    
                    // Convert to Arquero table
                    const cashFlowTable = aq.from(cashFlowData);
                    
                    // Calculate variances
                    const withVariances = this.deriveVarianceColumns(cashFlowTable);
                    
                    // Calculate category totals
                    const categoryTotals = this.calculateCategoryTotals(withVariances);
                    
                    // Calculate net change in cash
                    const totals = categoryTotals.objects();
                    let operating2024 = 0, operating2025 = 0;
                    let investing2024 = 0, investing2025 = 0;
                    let financing2024 = 0, financing2025 = 0;

                    totals.forEach(row => {
                        if (row.category === 'Operating Activities') {
                            operating2024 = row.amount_2024;
                            operating2025 = row.amount_2025;
                        } else if (row.category === 'Investing Activities') {
                            investing2024 = row.amount_2024;
                            investing2025 = row.amount_2025;
                        } else if (row.category === 'Financing Activities') {
                            financing2024 = row.amount_2024;
                            financing2025 = row.amount_2025;
                        }
                    });

                    const netChange2024 = operating2024 + investing2024 + financing2024;
                    const netChange2025 = operating2025 + investing2025 + financing2025;

                    // Get starting cash from Balance Sheet (cash and cash equivalents)
                    let startingCash2024 = 0, startingCash2025 = 0;
                    balanceDetails.forEach(row => {
                        if (row.subcategory && (
                            row.subcategory.toLowerCase().includes('liquide middelen') ||
                            row.subcategory.toLowerCase().includes('cash') ||
                            row.subcategory.toLowerCase().includes('bank')
                        )) {
                            startingCash2024 += row.amount_2024 || 0;
                            startingCash2025 += row.amount_2025 || 0;
                        }
                    });

                    // Calculate ending cash
                    const endingCash2024 = startingCash2024 + netChange2024;
                    const endingCash2025 = startingCash2025 + netChange2025;

                    return {
                        details: withVariances,
                        totals: categoryTotals,
                        metrics: {
                            netIncome: {
                                '2024': netIncome2024,
                                '2025': netIncome2025
                            },
                            netChange: {
                                '2024': netChange2024,
                                '2025': netChange2025,
                                variance: netChange2025 - netChange2024
                            },
                            startingCash: {
                                '2024': startingCash2024,
                                '2025': startingCash2025
                            },
                            endingCash: {
                                '2024': endingCash2024,
                                '2025': endingCash2025
                            }
                        }
                    };
                    
                } catch (error) {
                    console.error('Error generating Cash Flow Statement:', error);
                    throw error;
                }
            }

            // Calculate variance between two periods
            calculateVariance(period1, period2) {
                try {
                    const factTable1 = this.dataStore.getFactTable(period1);
                    const factTable2 = this.dataStore.getFactTable(period2);

                    if (!factTable1 || !factTable2) {
                        throw new Error(`Data for periods ${period1} or ${period2} not loaded`);
                    }

                    // Rename amount columns to distinguish periods
                    const table1 = factTable1
                        .select('account_code', 'account_description', 'movement_amount')
                        .rename({ movement_amount: `amount_${period1}` });

                    const table2 = factTable2
                        .select('account_code', 'movement_amount')
                        .rename({ movement_amount: `amount_${period2}` });

                    // Join tables on account_code
                    const joined = table1
                        .join_full(table2, 'account_code')
                        .derive({
                            [`amount_${period1}`]: d => d[`amount_${period1}`] || 0,
                            [`amount_${period2}`]: d => d[`amount_${period2}`] || 0,
                            variance_amount: d => (d[`amount_${period2}`] || 0) - (d[`amount_${period1}`] || 0),
                            variance_percent: d => {
                                const amt1 = d[`amount_${period1}`] || 0;
                                const amt2 = d[`amount_${period2}`] || 0;
                                
                                // Handle division by zero
                                if (amt1 === 0) {
                                    return amt2 === 0 ? 0 : null; // Return null for N/A cases
                                }
                                
                                return ((amt2 - amt1) / Math.abs(amt1)) * 100;
                            }
                        });

                    return joined;

                } catch (error) {
                    console.error('Error calculating variance:', error);
                    throw error;
                }
            }
        }

        // ExportHandler class for Excel export
        class ExportHandler {
            constructor(dataStore) {
                this.dataStore = dataStore;
            }

            // Convert Arquero table to array of arrays
            tableToArrays(table, includeHeaders = true) {
                const data = [];
                
                if (includeHeaders) {
                    data.push(table.columnNames());
                }
                
                table.objects().forEach(row => {
                    const rowArray = table.columnNames().map(col => row[col]);
                    data.push(rowArray);
                });
                
                return data;
            }

            // Export single statement to Excel
            async exportStatement(statementData, statementName) {
                try {
                    const workbook = new ExcelJS.Workbook();
                    const worksheet = workbook.addWorksheet(statementName);

                    // Convert statement data to array format
                    const headers = ['Line Item', '2024', '2025', 'Variance (‚Ç¨)', 'Variance (%)'];
                    const rows = [headers];

                    // Add details
                    const details = statementData.details.objects();
                    let currentCategory = null;

                    details.forEach(row => {
                        if (row.category !== currentCategory) {
                            currentCategory = row.category;
                            rows.push([currentCategory, '', '', '', '']);
                        }
                        rows.push([
                            '  ' + (row.subcategory || row.category),
                            row.amount_2024,
                            row.amount_2025,
                            row.variance_amount,
                            row.variance_percent
                        ]);
                    });

                    // Add empty row
                    rows.push(['', '', '', '', '']);

                    // Add totals
                    rows.push(['Category Totals', '', '', '', '']);
                    const totals = statementData.totals.objects();
                    totals.forEach(row => {
                        rows.push([
                            'Total ' + row.category,
                            row.amount_2024,
                            row.amount_2025,
                            row.variance_amount,
                            row.variance_percent
                        ]);
                    });

                    // Add rows to worksheet
                    rows.forEach((row, index) => {
                        const excelRow = worksheet.addRow(row);
                        
                        // Format header row
                        if (index === 0) {
                            excelRow.font = { bold: true };
                            excelRow.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: 'FF007bff' }
                            };
                            excelRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                        }
                        
                        // Format number columns
                        for (let i = 2; i <= 5; i++) {
                            if (excelRow.getCell(i).value !== '') {
                                excelRow.getCell(i).numFmt = '#,##0.00';
                            }
                        }
                    });

                    // Auto-size columns
                    worksheet.columns.forEach(column => {
                        column.width = 20;
                    });

                    // Generate buffer and download
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${statementName}.xlsx`;
                    link.click();
                    window.URL.revokeObjectURL(url);

                    console.log(`Exported ${statementName} successfully`);

                } catch (error) {
                    console.error('Error exporting statement:', error);
                    throw error;
                }
            }

            // Export all statements to single workbook
            async exportAllStatements(statements) {
                try {
                    const workbook = new ExcelJS.Workbook();

                    // Add each statement as a separate worksheet
                    for (const [name, data] of Object.entries(statements)) {
                        const worksheet = workbook.addWorksheet(name);

                        const headers = ['Line Item', '2024', '2025', 'Variance (‚Ç¨)', 'Variance (%)'];
                        const rows = [headers];

                        // Add details
                        const details = data.details.objects();
                        let currentCategory = null;

                        details.forEach(row => {
                            if (row.category !== currentCategory) {
                                currentCategory = row.category;
                                rows.push([currentCategory, '', '', '', '']);
                            }
                            rows.push([
                                '  ' + (row.subcategory || row.category),
                                row.amount_2024,
                                row.amount_2025,
                                row.variance_amount,
                                row.variance_percent
                            ]);
                        });

                        rows.push(['', '', '', '', '']);
                        rows.push(['Category Totals', '', '', '', '']);
                        
                        const totals = data.totals.objects();
                        totals.forEach(row => {
                            rows.push([
                                'Total ' + row.category,
                                row.amount_2024,
                                row.amount_2025,
                                row.variance_amount,
                                row.variance_percent
                            ]);
                        });

                        // Add rows to worksheet
                        rows.forEach((row, index) => {
                            const excelRow = worksheet.addRow(row);
                            
                            if (index === 0) {
                                excelRow.font = { bold: true };
                                excelRow.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FF007bff' }
                                };
                                excelRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                            }
                            
                            for (let i = 2; i <= 5; i++) {
                                if (excelRow.getCell(i).value !== '') {
                                    excelRow.getCell(i).numFmt = '#,##0.00';
                                }
                            }
                        });

                        worksheet.columns.forEach(column => {
                            column.width = 20;
                        });
                    }

                    // Generate buffer and download
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = config.outputFiles.allStatements;
                    link.click();
                    window.URL.revokeObjectURL(url);

                    console.log('Exported all statements successfully');

                } catch (error) {
                    console.error('Error exporting all statements:', error);
                    throw error;
                }
            }
        }

        // InteractiveUI class for rendering financial statements
        class InteractiveUI {
            constructor() {
                this.currentStatement = null;
                this.sortColumn = null;
                this.sortDirection = 'asc';
            }

            // Format number with thousand separators (whole numbers, no decimals)
            formatNumber(value) {
                if (value === null || value === undefined) return 'N/A';
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(Math.round(value));
            }

            // Helper function to render data cells based on year toggles
            renderDataCells(amount2024, amount2025, varianceAmount, variancePercent, show2024, show2025, showVariance, cssClass = 'number') {
                let html = '';
                if (show2024) {
                    html += `<td class="${cssClass}">${this.formatNumber(amount2024)}</td>`;
                }
                if (show2025) {
                    html += `<td class="${cssClass}">${this.formatNumber(amount2025)}</td>`;
                }
                if (showVariance) {
                    html += `<td class="${cssClass} ${varianceAmount >= 0 ? 'positive' : 'negative'}">${this.formatNumber(varianceAmount)}</td>`;
                    html += `<td class="${cssClass} ${variancePercent >= 0 ? 'positive' : 'negative'}">${this.formatNumber(variancePercent)}%</td>`;
                }
                return html;
            }

            // Render statement table
            renderStatement(statementData, statementType, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                this.currentStatement = statementData;
                this.currentStatementType = statementType;

                // Create table HTML
                let html = '<table class="financial-table">';
                
                // Check which years and variance should be shown
                // Try header checkboxes first, fall back to true if not found (initial render)
                const header2024Checkbox = document.getElementById('show-2024-header');
                const header2025Checkbox = document.getElementById('show-2025-header');
                const show2024 = header2024Checkbox ? header2024Checkbox.checked : true;
                const show2025 = header2025Checkbox ? header2025Checkbox.checked : true;
                const showVariance = document.getElementById('show-variance')?.checked !== false && show2024 && show2025;
                
                // Calculate column span dynamically
                let colCount = 1; // Line Item column
                if (show2024) colCount++;
                if (show2025) colCount++;
                if (showVariance) colCount += 2;
                const colSpan = colCount;
                
                // Table header
                html += '<thead><tr>';
                html += '<th class="col-label">Line Item</th>';
                if (show2024) {
                    html += '<th class="col-number">';
                    html += '<label style="cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: center; gap: 5px;">';
                    html += '<input type="checkbox" id="show-2024-header" checked style="cursor: pointer;">';
                    html += '<span>2024</span>';
                    html += '</label>';
                    html += '</th>';
                }
                if (show2025) {
                    html += '<th class="col-number">';
                    html += '<label style="cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: center; gap: 5px;">';
                    html += '<input type="checkbox" id="show-2025-header" checked style="cursor: pointer;">';
                    html += '<span>2025</span>';
                    html += '</label>';
                    html += '</th>';
                }
                if (showVariance) {
                    html += '<th class="col-number">Variance (‚Ç¨)</th>';
                    html += '<th class="col-number">Variance (%)</th>';
                }
                html += '</tr></thead>';
                
                html += '<tbody>';

                // Render details grouped by category
                const details = statementData.details.objects();
                const totals = statementData.totals.objects();
                
                // Pre-calculate Total Assets for Balance Sheet (to insert in the middle)
                let totalAssets2024 = 0, totalAssets2025 = 0;
                let totalAssetsInserted = false;
                if (statementType === 'balance-sheet') {
                    totals.forEach(row => {
                        const categoryLower = row.category.toLowerCase();
                        if (categoryLower.includes('activa') || categoryLower.includes('asset')) {
                            totalAssets2024 += row.amount_2024 || 0;
                            totalAssets2025 += row.amount_2025 || 0;
                        }
                    });
                }
                
                // Flag to ensure Operating Income is only inserted once
                let operatingIncomeInserted = false;
                
                let currentCategory = null;
                
                details.forEach(row => {
                    // Insert Total Assets before first Passiva/Eigen vermogen category for Balance Sheet
                    if (statementType === 'balance-sheet' && 
                        !totalAssetsInserted &&
                        row.category !== currentCategory) {
                        const categoryLower = row.category.toLowerCase();
                        if (categoryLower.includes('passiva') || categoryLower.includes('vermogen') || 
                            categoryLower.includes('liabilit') || categoryLower.includes('equity')) {
                            
                            totalAssetsInserted = true;
                            const assetsVariance = totalAssets2025 - totalAssets2024;
                            const assetsVariancePercent = totalAssets2024 !== 0 ? (assetsVariance / Math.abs(totalAssets2024)) * 100 : 0;
                            
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                            html += '<tr class="total-row">';
                            html += '<td><strong>TOTAL ASSETS</strong></td>';
                            html += this.renderDataCells(totalAssets2024, totalAssets2025, assetsVariance, assetsVariancePercent, show2024, show2025, showVariance, 'number');
                            html += '</tr>';
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                        }
                    }
                    
                    // Insert Operating Income inline before "Financiele baten en lasten" category for Income Statement (only once)
                    if (statementType === 'income-statement' && 
                        statementData.metrics && 
                        !operatingIncomeInserted &&
                        row.category !== currentCategory &&
                        (row.category.toLowerCase().includes('financiele') || 
                         row.category.toLowerCase().includes('financial') ||
                         row.category.toLowerCase().includes('baten') ||
                         row.category.toLowerCase().includes('lasten'))) {
                        
                        operatingIncomeInserted = true;
                        
                        const metrics = statementData.metrics;
                        const oiVariance = metrics.operatingIncome['2025'] - metrics.operatingIncome['2024'];
                        const oiVariancePercent = metrics.operatingIncome['2024'] !== 0 ? 
                            (oiVariance / Math.abs(metrics.operatingIncome['2024'])) * 100 : 0;
                        
                        html += '<tr class="metric-row">';
                        html += '<td><strong>Operating Income</strong></td>';
                        html += this.renderDataCells(metrics.operatingIncome['2024'], metrics.operatingIncome['2025'], oiVariance, oiVariancePercent, show2024, show2025, showVariance, 'number');
                        html += '</tr>';
                        
                        // Empty line after Operating Income
                        html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    }
                    
                    // Add category header if changed
                    if (row.category !== currentCategory) {
                        currentCategory = row.category;
                        html += `<tr class="category-header"><td colspan="${colSpan}"><strong>${currentCategory}</strong></td></tr>`;
                    }
                    
                    // Add detail row - always show if subcategory exists
                    const shouldShowDetail = row.subcategory;
                    
                    if (shouldShowDetail) {
                        html += '<tr class="detail-row">';
                        html += `<td class="indent">${row.subcategory}</td>`;
                        html += this.renderDataCells(row.amount_2024, row.amount_2025, row.variance_amount, row.variance_percent, show2024, show2025, showVariance);
                        html += '</tr>';
                        
                        // Insert Gross Profit inline after "Kostprijs van de omzet" for Income Statement
                        if (statementType === 'income-statement' && 
                            statementData.metrics && 
                            row.subcategory.toLowerCase().includes('kostprijs')) {
                            
                            const metrics = statementData.metrics;
                            const gpVariance = metrics.grossProfit['2025'] - metrics.grossProfit['2024'];
                            const gpVariancePercent = metrics.grossProfit['2024'] !== 0 ? 
                                (gpVariance / Math.abs(metrics.grossProfit['2024'])) * 100 : 0;
                            
                            html += '<tr class="metric-row">';
                            html += '<td><strong>Brutowinst (Gross Profit)</strong></td>';
                            html += this.renderDataCells(metrics.grossProfit['2024'], metrics.grossProfit['2025'], gpVariance, gpVariancePercent, show2024, show2025, showVariance, 'number');
                            html += '</tr>';
                            
                            // Empty line after Gross Profit
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                        }
                    }
                });

                // Check if category totals should be shown
                const showCategoryTotals = document.getElementById('show-category-totals')?.checked !== false;
                
                // Calculate grand totals for Balance Sheet (Liabilities & Equity only, Assets already shown)
                let totalLiabilitiesEquity2024 = 0, totalLiabilitiesEquity2025 = 0;
                
                // Add category totals (optional)
                if (showCategoryTotals) {
                    html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                    html += '<tr class="section-header"><td colspan="5"><strong>Category Totals</strong></td></tr>';
                }
                
                totals.forEach(row => {
                    if (showCategoryTotals) {
                        html += '<tr class="subtotal-row">';
                        html += `<td><strong>Total ${row.category}</strong></td>`;
                        html += this.renderDataCells(row.amount_2024, row.amount_2025, row.variance_amount, row.variance_percent, show2024, show2025, showVariance, 'number');
                        html += '</tr>';
                    }
                    
                    // Accumulate for Balance Sheet Liabilities & Equity total
                    if (statementType === 'balance-sheet') {
                        const categoryLower = row.category.toLowerCase();
                        if (categoryLower.includes('passiva') || categoryLower.includes('liabilit') || 
                            categoryLower.includes('vermogen') || categoryLower.includes('equity') ||
                            categoryLower.includes('schuld')) {
                            totalLiabilitiesEquity2024 += row.amount_2024 || 0;
                            totalLiabilitiesEquity2025 += row.amount_2025 || 0;
                        }
                    }
                });
                
                // Add Balance Sheet Liabilities & Equity total at the end
                if (statementType === 'balance-sheet' && (totalLiabilitiesEquity2024 !== 0 || totalLiabilitiesEquity2025 !== 0)) {
                    const leVariance = totalLiabilitiesEquity2025 - totalLiabilitiesEquity2024;
                    const leVariancePercent = totalLiabilitiesEquity2024 !== 0 ? (leVariance / Math.abs(totalLiabilitiesEquity2024)) * 100 : 0;
                    
                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    
                    // Total Liabilities & Equity
                    html += '<tr class="total-row">';
                    html += '<td><strong>TOTAL LIABILITIES & EQUITY</strong></td>';
                    html += this.renderDataCells(totalLiabilitiesEquity2024, totalLiabilitiesEquity2025, leVariance, leVariancePercent, show2024, show2025, showVariance, 'number');
                    html += '</tr>';
                }

                // Add Net Income at the bottom for Income Statement (after all categories, similar to bottom line)
                if (statementType === 'income-statement' && statementData.metrics) {
                    const metrics = statementData.metrics;
                    const niVariance = metrics.netIncome['2025'] - metrics.netIncome['2024'];
                    const niVariancePercent = metrics.netIncome['2024'] !== 0 ? 
                        (niVariance / Math.abs(metrics.netIncome['2024'])) * 100 : 0;
                    
                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    html += '<tr class="total-row">';
                    html += '<td><strong>Net Income</strong></td>';
                    html += this.renderDataCells(metrics.netIncome['2024'], metrics.netIncome['2025'], niVariance, niVariancePercent, show2024, show2025, showVariance, 'number');
                    html += '</tr>';
                }

                // Add cash reconciliation for Cash Flow Statement
                if (statementType === 'cash-flow' && statementData.metrics) {
                    const metrics = statementData.metrics;
                    
                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    html += `<tr class="section-header"><td colspan="${colSpan}"><strong>Cash Reconciliation</strong></td></tr>`;
                    
                    // Starting Cash
                    if (metrics.startingCash) {
                        const scVariance = metrics.startingCash['2025'] - metrics.startingCash['2024'];
                        const scVariancePercent = metrics.startingCash['2024'] !== 0 ? 
                            (scVariance / Math.abs(metrics.startingCash['2024'])) * 100 : 0;
                        
                        html += '<tr class="detail-row">';
                        html += '<td>Starting Cash</td>';
                        html += this.renderDataCells(metrics.startingCash['2024'], metrics.startingCash['2025'], scVariance, scVariancePercent, show2024, show2025, showVariance);
                        html += '</tr>';
                    }
                    
                    // Net Change in Cash
                    if (metrics.netChange) {
                        const ncVariance = metrics.netChange.variance;
                        const ncVariancePercent = metrics.netChange['2024'] !== 0 ? 
                            (ncVariance / Math.abs(metrics.netChange['2024'])) * 100 : 0;
                        
                        html += '<tr class="detail-row">';
                        html += '<td>Changes in Cash</td>';
                        html += this.renderDataCells(metrics.netChange['2024'], metrics.netChange['2025'], ncVariance, ncVariancePercent, show2024, show2025, showVariance);
                        html += '</tr>';
                    }
                    
                    // Ending Cash
                    if (metrics.endingCash) {
                        const ecVariance = metrics.endingCash['2025'] - metrics.endingCash['2024'];
                        const ecVariancePercent = metrics.endingCash['2024'] !== 0 ? 
                            (ecVariance / Math.abs(metrics.endingCash['2024'])) * 100 : 0;
                        
                        html += '<tr class="total-row">';
                        html += '<td><strong>Ending Cash</strong></td>';
                        html += this.renderDataCells(metrics.endingCash['2024'], metrics.endingCash['2025'], ecVariance, ecVariancePercent, show2024, show2025, showVariance, 'number');
                        html += '</tr>';
                    }
                }

                // Add balance check for Balance Sheet
                if (statementType === 'balance-sheet' && statementData.balanced !== undefined) {
                    html += '<tr class="spacer-row"><td colspan="5"></td></tr>';
                    if (statementData.balanced) {
                        html += '<tr class="info-row"><td colspan="5" class="success-message">‚úÖ Balance Sheet is balanced</td></tr>';
                    } else {
                        html += `<tr class="info-row"><td colspan="5" class="warning-message">‚ö†Ô∏è Balance Sheet imbalance: ${this.formatNumber(statementData.imbalance)}</td></tr>`;
                    }
                }

                html += '</tbody></table>';
                
                container.innerHTML = html;
                
                // Add event listeners for header checkboxes
                const show2024HeaderCheckbox = container.querySelector('#show-2024-header');
                const show2025HeaderCheckbox = container.querySelector('#show-2025-header');
                
                if (show2024HeaderCheckbox) {
                    show2024HeaderCheckbox.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-render the current statement with year visibility changes
                        if (this.currentStatementType && this.currentStatement) {
                            this.renderStatement(this.currentStatement, this.currentStatementType, container.id);
                        }
                    });
                }
                
                if (show2025HeaderCheckbox) {
                    show2025HeaderCheckbox.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-render the current statement with year visibility changes
                        if (this.currentStatementType && this.currentStatement) {
                            this.renderStatement(this.currentStatement, this.currentStatementType, container.id);
                        }
                    });
                }
                
                // Enable tooltips
                this.enableTooltips(container);
            }

            // Sorting functionality removed - not needed

            // Enable drill-down on subtotal rows (placeholder for future implementation)
            enableDrillDown(container) {
                // This would expand/collapse detail rows under subtotals
                // Implementation depends on data structure with hierarchical relationships
                console.log('Drill-down feature: To be implemented with hierarchical data');
            }

            // Enable filtering (placeholder for future implementation)
            enableFiltering(container) {
                // This would add filter controls and apply filters to the data
                console.log('Filtering feature: To be implemented');
            }

            // Enable tooltips on amount cells
            enableTooltips(container) {
                const numberCells = container.querySelectorAll('td.number');
                
                numberCells.forEach(cell => {
                    cell.addEventListener('mouseenter', (e) => {
                        this.showTooltip(e.target, {
                            value: cell.textContent,
                            info: 'Hover for details'
                        });
                    });
                    
                    cell.addEventListener('mouseleave', () => {
                        this.hideTooltip();
                    });
                });
            }

            // Show tooltip
            showTooltip(element, data) {
                // Remove existing tooltip
                this.hideTooltip();
                
                // Create tooltip element
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.id = 'financial-tooltip';
                
                // Tooltip content
                tooltip.innerHTML = `
                    <div class="tooltip-content">
                        <strong>Value:</strong> ${data.value}<br>
                        <em>${data.info}</em>
                    </div>
                `;
                
                document.body.appendChild(tooltip);
                
                // Position tooltip near cursor
                const rect = element.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';
            }

            // Hide tooltip
            hideTooltip() {
                const tooltip = document.getElementById('financial-tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.dataStore = new DataStore();
                this.dataLoader = new DataLoader();
                this.statementGenerator = new StatementGenerator(this.dataStore);
                this.interactiveUI = new InteractiveUI();
                this.exportHandler = new ExportHandler(this.dataStore);
                this.currentStatementType = 'balance-sheet';
                this.currentStatementData = null;
            }

            // Update file status indicator
            updateFileStatus(fileId, status, message) {
                const statusElement = document.getElementById(`status-${fileId}`);
                if (statusElement) {
                    if (status === 'success') {
                        statusElement.textContent = message ? `‚úÖ ${message}` : '‚úÖ';
                        statusElement.style.color = '#28a745';
                    } else if (status === 'error') {
                        statusElement.textContent = '‚ùå';
                        statusElement.style.color = '#dc3545';
                    } else if (status === 'loading') {
                        statusElement.textContent = '‚è≥';
                        statusElement.style.color = '#ffc107';
                    }
                }
            }

            // Show loading message
            showLoadingMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = message;
                    loadingStatus.style.color = '#007bff';
                }
            }

            // Show error message
            showErrorMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = '‚ùå ' + message;
                    loadingStatus.style.color = '#dc3545';
                }
            }

            // Show success message
            showSuccessMessage(message) {
                const loadingStatus = document.getElementById('loading-status');
                if (loadingStatus) {
                    loadingStatus.textContent = '‚úÖ ' + message;
                    loadingStatus.style.color = '#28a745';
                }
            }

            // Handle input directory selection
            async handleSelectInputDirectory() {
                try {
                    await this.dataLoader.selectInputDirectory();
                    const statusText = document.getElementById('input-dir-status');
                    statusText.textContent = `üìÅ ${this.dataLoader.inputDirHandle.name}`;
                    statusText.style.color = '#28a745';
                    
                    // Enable load button
                    document.getElementById('load-all-files').disabled = false;
                } catch (error) {
                    this.showErrorMessage(error.message);
                }
            }

            // Load all files
            async handleLoadAllFiles() {
                this.showLoadingMessage('Loading trial balance files...');
                
                try {
                    // Step 1: Load trial balance for 2024 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2024 trial balance...');
                    this.updateFileStatus('tb2024', 'loading');
                    const { movements: movements2024, balances: balances2024 } = await this.dataLoader.loadTrialBalance('2024');
                    
                    this.dataStore.setFactTable(movements2024, '2024', 'movements');
                    this.dataStore.setFactTable(balances2024, '2024', 'balances');
                    this.updateFileStatus('tb2024', 'success', `M:${movements2024.numRows()} B:${balances2024.numRows()}`);

                    // Step 2: Load trial balance for 2025 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2025 trial balance...');
                    this.updateFileStatus('tb2025', 'loading');
                    const { movements: movements2025, balances: balances2025 } = await this.dataLoader.loadTrialBalance('2025');
                    
                    this.dataStore.setFactTable(movements2025, '2025', 'movements');
                    this.dataStore.setFactTable(balances2025, '2025', 'balances');
                    this.updateFileStatus('tb2025', 'success', `M:${movements2025.numRows()} B:${balances2025.numRows()}`);
                    
                    // Step 3: Create combined movements table for both years
                    this.showLoadingMessage('Combining data...');
                    const combinedMovements = movements2024.concat(movements2025);
                    this.dataStore.setCombinedMovements(combinedMovements);
                    console.log(`Combined movements table created: ${combinedMovements.numRows()} rows`);
                    
                    // Update combined TB count
                    const combinedCount = movements2024.numRows() + balances2024.numRows() + movements2025.numRows() + balances2025.numRows();
                    this.updateFileStatus('tb2425', 'success', `(${combinedCount} total)`);

                    // Get loaded years from DataStore
                    const loadedYears = this.dataStore.getAllPeriods();
                    console.log(`Loaded trial balance years: ${loadedYears.join(', ')}`);

                    this.showSuccessMessage('Files loaded');
                    
                    // Validate data and show results
                    this.validateAndDisplayResults();
                    
                    // Show statement section
                    document.getElementById('statement-section').style.display = 'block';
                    
                    // Enable export button
                    document.getElementById('export-all').disabled = false;
                    
                    // Generate and display default statement (Balance Sheet)
                    this.generateAndDisplayStatement('balance-sheet');

                } catch (error) {
                    this.showErrorMessage(error.message);
                    console.error('File loading error:', error);
                    console.error('Error stack:', error.stack);
                    
                    // Update status indicators to show error
                    this.updateFileStatus('tb2024', 'error');
                    this.updateFileStatus('tb2025', 'error');
                    this.updateFileStatus('hierarchy', 'error');
                }
            }

            // Validate data and display results
            validateAndDisplayResults() {
                const validation = this.statementGenerator.validateData();
                const validationContainer = document.getElementById('validation-messages');
                const errorsContainer = document.getElementById('validation-errors');
                const warningsContainer = document.getElementById('validation-warnings');

                // Clear previous messages
                errorsContainer.innerHTML = '';
                warningsContainer.innerHTML = '';

                // Display Afrondingsverschil replacements
                if (window.afrondingsReplacements && window.afrondingsReplacements.length > 0) {
                    window.afrondingsReplacements.forEach(replacement => {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'validation-warning-item';
                        infoDiv.innerHTML = `‚ÑπÔ∏è <strong>Account replaced:</strong> ${replacement}`;
                        warningsContainer.appendChild(infoDiv);
                    });
                }

                // Display errors
                if (validation.errors.length > 0) {
                    validation.errors.forEach(error => {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'validation-error-item';
                        errorDiv.textContent = '‚ùå ' + error;
                        errorsContainer.appendChild(errorDiv);
                    });
                }

                // Display warnings
                if (validation.warnings.length > 0) {
                    validation.warnings.forEach(warning => {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'validation-warning-item';
                        warningDiv.textContent = '‚ö†Ô∏è ' + warning;
                        warningsContainer.appendChild(warningDiv);
                    });
                }

                // Display unmapped accounts if any
                if (validation.unmappedAccounts.length > 0) {
                    const unmappedDiv = document.createElement('div');
                    unmappedDiv.className = 'validation-warning-item';
                    unmappedDiv.innerHTML = `
                        <strong>Unmapped Accounts (${validation.unmappedAccounts.length}):</strong>
                        <div class="unmapped-accounts-list">
                            ${validation.unmappedAccounts.join(', ')}
                        </div>
                    `;
                    warningsContainer.appendChild(unmappedDiv);
                }

                // Show validation container if there are any messages
                if (validation.errors.length > 0 || validation.warnings.length > 0) {
                    validationContainer.style.display = 'block';
                } else {
                    validationContainer.style.display = 'none';
                }
            }

            // Generate and display statement
            generateAndDisplayStatement(statementType) {
                try {
                    // Get period selections
                    const period2024 = document.getElementById('period-2024')?.value || 'all';
                    const period2025 = document.getElementById('period-2025')?.value || 'all';
                    const periodOptions = { period2024, period2025 };
                    
                    let statementData;
                    
                    switch(statementType) {
                        case 'balance-sheet':
                            statementData = this.statementGenerator.generateBalanceSheet(periodOptions);
                            break;
                        case 'income-statement':
                            statementData = this.statementGenerator.generateIncomeStatement(periodOptions);
                            break;
                        case 'cash-flow':
                            statementData = this.statementGenerator.generateCashFlowStatement(periodOptions);
                            break;
                        default:
                            throw new Error('Unknown statement type');
                    }
                    
                    this.interactiveUI.renderStatement(statementData, statementType, 'statement-display');
                    this.currentStatementType = statementType;
                    this.currentStatementData = statementData;
                    
                } catch (error) {
                    console.error('Error generating statement:', error);
                    const display = document.getElementById('statement-display');
                    if (display) {
                        display.innerHTML = `<div class="error-message">Error generating statement: ${error.message}</div>`;
                    }
                }
            }

            // Handle export all statements
            async handleExportAll() {
                try {
                    this.showExportStatus('Exporting all statements...', 'loading');
                    
                    // Get period selections
                    const period2024 = document.getElementById('period-2024')?.value || 'all';
                    const period2025 = document.getElementById('period-2025')?.value || 'all';
                    const periodOptions = { period2024, period2025 };
                    
                    const statements = {
                        'Balance Sheet': this.statementGenerator.generateBalanceSheet(periodOptions),
                        'Income Statement': this.statementGenerator.generateIncomeStatement(periodOptions),
                        'Cash Flow': this.statementGenerator.generateCashFlowStatement(periodOptions)
                    };
                    
                    await this.exportHandler.exportAllStatements(statements);
                    
                    this.showExportStatus('All statements exported successfully!', 'success');
                    
                } catch (error) {
                    this.showExportStatus('Export failed: ' + error.message, 'error');
                    console.error('Export error:', error);
                }
            }

            // Show export status message
            showExportStatus(message, type) {
                const statusElement = document.getElementById('export-status');
                if (statusElement) {
                    statusElement.textContent = message;
                    
                    if (type === 'success') {
                        statusElement.style.color = '#28a745';
                    } else if (type === 'error') {
                        statusElement.style.color = '#dc3545';
                    } else if (type === 'loading') {
                        statusElement.style.color = '#007bff';
                    }
                    
                    // Clear message after 3 seconds
                    if (type !== 'loading') {
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    }
                }
            }

            // Handle tab switching
            handleTabSwitch(statementType) {
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.statement === statementType) {
                        btn.classList.add('active');
                    }
                });
                
                // Generate and display the selected statement
                this.generateAndDisplayStatement(statementType);
            }

            // Show data preview
            showDataPreview(fileId) {
                let table = null;
                let title = '';
                
                switch(fileId) {
                    case 'tb2024':
                        table = this.dataStore.getMovementsTable('2024');
                        title = 'Trial Balance 2024 Movements - First 20 Rows';
                        break;
                    case 'tb2025':
                        table = this.dataStore.getMovementsTable('2025');
                        title = 'Trial Balance 2025 Movements - First 20 Rows';
                        break;
                    case 'tb2425':
                        // Combine both movements tables
                        const tb2024m = this.dataStore.getMovementsTable('2024');
                        const tb2025m = this.dataStore.getMovementsTable('2025');
                        if (tb2024m && tb2025m) {
                            table = tb2024m.concat(tb2025m);
                            const rowCount = table.numRows();
                            title = `Combined Movements 2024+2025 - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                }
                
                if (!table) {
                    return;
                }
                
                const previewDiv = document.getElementById('data-preview');
                const titleDiv = document.getElementById('preview-title');
                const contentDiv = document.getElementById('preview-content');
                
                titleDiv.textContent = title;
                
                // Get first 20 rows
                const rows = table.slice(0, 20).objects();
                const columns = table.columnNames();
                
                // Build table HTML
                let html = '<table><thead><tr>';
                columns.forEach(col => {
                    html += `<th>${col}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                rows.forEach(row => {
                    html += '<tr>';
                    columns.forEach(col => {
                        const value = row[col];
                        const displayValue = value !== null && value !== undefined ? value : '';
                        html += `<td>${displayValue}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                contentDiv.innerHTML = html;
                previewDiv.style.display = 'block';
            }

            // Setup event listeners
            setupEventListeners() {
                document.getElementById('select-input-dir').addEventListener('click', () => {
                    this.handleSelectInputDirectory();
                });

                document.getElementById('load-all-files').addEventListener('click', () => {
                    this.handleLoadAllFiles();
                });

                // Tab switching
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.handleTabSwitch(btn.dataset.statement);
                    });
                });

                // Export button
                document.getElementById('export-all').addEventListener('click', () => {
                    this.handleExportAll();
                });
                
                // File preview clicks
                document.querySelectorAll('.file-status-item.clickable').forEach(item => {
                    item.addEventListener('click', () => {
                        const fileId = item.dataset.file;
                        this.showDataPreview(fileId);
                    });
                });
                
                // Close preview button
                document.getElementById('close-preview').addEventListener('click', () => {
                    document.getElementById('data-preview').style.display = 'none';
                });
                
                // Variance toggle
                document.getElementById('show-variance')?.addEventListener('change', () => {
                    // Re-render the current statement
                    if (this.currentStatementType) {
                        this.handleTabSwitch(this.currentStatementType);
                    }
                });
                
                // Category totals toggle
                document.getElementById('show-category-totals')?.addEventListener('change', () => {
                    // Re-render the current statement
                    if (this.currentStatementType) {
                        this.handleTabSwitch(this.currentStatementType);
                    }
                });
                
                // Period selection dropdowns
                document.getElementById('period-2024')?.addEventListener('change', () => {
                    // Re-generate and render the current statement with new period filter
                    if (this.currentStatementType) {
                        this.generateAndDisplayStatement(this.currentStatementType);
                    }
                });
                
                document.getElementById('period-2025')?.addEventListener('change', () => {
                    // Re-generate and render the current statement with new period filter
                    if (this.currentStatementType) {
                        this.generateAndDisplayStatement(this.currentStatementType);
                    }
                });
                
            }
        }

        // Initialize application
        async function init() {
            console.log('Financial Statement Generator initialized');
            console.log('Arquero loaded:', typeof aq !== 'undefined');
            console.log('ExcelJS loaded:', typeof ExcelJS !== 'undefined');
            
            // Check browser compatibility
            if (!window.showDirectoryPicker) {
                alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
                console.error('File System Access API not supported');
            }
            
            // Load configuration
            await loadConfig();
            
            // Initialize UI Controller
            window.uiController = new UIController();
            window.uiController.setupEventListeners();
            
            // Initial state: disable export button until data is loaded
            document.getElementById('export-all').disabled = true;
            
            console.log('Application ready');
            console.log('Configuration:', config);
        }

        // Run initialization when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
