<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statement Generator</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/arquero@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/exceljs@latest/dist/exceljs.min.js"></script>
    
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-size: 13px;
        }

        #app {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .section {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            transition: box-shadow 0.3s ease;
        }

        .section:hover {
            box-shadow: 0 10px 15px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.1);
        }

        h2 {
            margin-bottom: 12px;
            color: #2d3748;
            font-size: 1.1em;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 6px;
        }

        .directory-selection {
            margin-bottom: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-right: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(245, 87, 108, 0.4);
        }

        .btn:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .status-text {
            color: #666;
            font-size: 12px;
        }

        .file-loading {
            margin-bottom: 12px;
        }

        .loading-status {
            margin-top: 8px;
            min-height: 18px;
            color: #666;
            font-size: 12px;
        }

        .file-status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .file-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 4px;
            border-left: 3px solid #667eea;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .file-status-item.clickable {
            cursor: pointer;
        }

        .file-status-item.clickable:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }

        .file-status-item.clickable.loaded {
            cursor: pointer;
        }

        .file-status-item:not(.clickable):hover {
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #data-preview table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        #data-preview th {
            background-color: #667eea;
            color: white;
            padding: 6px 8px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        #data-preview td {
            padding: 4px 8px;
            border-bottom: 1px solid #e9ecef;
        }

        #data-preview tr:hover {
            background-color: #f8f9fa;
        }

        .file-label {
            font-weight: 600;
            color: #2d3748;
        }

        .status-indicator {
            font-size: 12px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 3px;
        }

        .tab-btn {
            padding: 8px 16px;
            border: none;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: 4px 4px 0 0;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            color: #4a5568;
        }

        .tab-btn:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            transform: translateY(-1px);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-color: #667eea;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .statement-display {
            min-height: 400px;
            overflow-x: auto;
        }

        .financial-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .financial-table th {
            background-color: #007bff;
            color: white;
            padding: 8px 6px;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        .financial-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .financial-table th.sortable:hover {
            background-color: #0056b3;
        }

        .financial-table th.col-number {
            text-align: right;
        }

        .financial-table td {
            padding: 6px;
            border-bottom: 1px solid #e9ecef;
        }

        .financial-table td.number {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .financial-table td.indent {
            padding-left: 24px;
        }

        .financial-table tr.detail-row:hover {
            background-color: #f8f9fa;
        }

        .financial-table tr.name1-header td {
            background-color: #e9ecef;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #007bff;
        }

        .financial-table tr.subtotal-row td {
            background-color: #f8f9fa;
            border-top: 2px solid #333;
            border-bottom: 2px solid #333;
            padding: 8px 6px;
        }

        .financial-table tr.total-row td {
            background-color: #e7f3ff;
            border-top: 3px double #007bff;
            border-bottom: 3px double #007bff;
            padding: 8px 6px;
            font-size: 13px;
        }

        .financial-table tr.metric-row td {
            background-color: #fff3cd;
            padding: 8px 6px;
        }

        .financial-table tr.section-header td {
            background-color: #d1ecf1;
            font-weight: 600;
            padding: 8px 6px;
            border-top: 2px solid #0c5460;
        }

        .financial-table tr.spacer-row td {
            padding: 3px;
            border: none;
        }

        .financial-table tr.info-row td {
            padding: 8px 6px;
            text-align: center;
            font-weight: 500;
        }

        .financial-table .positive {
            color: #28a745;
        }

        .financial-table .negative {
            color: #dc3545;
        }

        .success-message {
            color: #28a745;
            background-color: #d4edda;
        }

        .warning-message {
            color: #856404;
            background-color: #fff3cd;
        }

        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .tooltip-content {
            line-height: 1.5;
        }

        .export-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .validation-messages {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            font-size: 12px;
        }

        .validation-errors {
            margin-bottom: 8px;
        }

        .validation-errors:empty {
            display: none;
        }

        .validation-warnings:empty {
            display: none;
        }

        .validation-error-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #f8d7da;
            color: #721c24;
            border-left: 3px solid #dc3545;
            border-radius: 3px;
        }

        .validation-warning-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background-color: #fff3cd;
            color: #856404;
            border-left: 3px solid #ffc107;
            border-radius: 3px;
        }

        .unmapped-accounts-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 5px;
            padding: 8px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        /* Header dropdown styling */
        .period-dropdown-header {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .period-dropdown-header option {
            background: #007bff;
            color: white;
        }

        .variance-dropdown {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .variance-dropdown option {
            background: #007bff;
            color: white;
        }

        .detail-level-dropdown {
            width: auto;
            min-width: 120px;
        }

        /* Dev toggle (CSS-only): if the checkbox is unchecked hide the data controls */
        #dev-toggle:not(:checked) ~ #data-controls {
            display: none !important;
        }
        #dev-toggle:checked ~ #data-controls {
            display: flex !important;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Statement Generator <span style="font-size: 0.6em; color: rgba(255,255,255,0.8);">v2.9.0</span></h1>
        
        <!-- File Upload Section -->
        <div id="file-upload-section" class="section">
            <h2>Data Files</h2>
            
            <div style="display: flex; gap: 15px; align-items: flex-start; margin-bottom: 15px;">
                <!-- Left side: Button and status -->
                <div style="flex: 1; min-width: 300px;">
                    <div style="margin-bottom: 8px; display:flex; gap:8px; align-items:center;">
                        <button id="select-input-dir" class="btn btn-primary">Select Directory</button>

                        <!-- Dev toggle: when off, hide the data controls -->
                        <div style="display:flex; align-items:center; gap:6px;">
                            <input type="checkbox" id="dev-toggle" checked style="width:18px; height:18px;" />
                            <label for="dev-toggle" style="font-size:13px; color:#4a5568; font-weight:600; cursor:pointer;">Dev</label>
                        </div>

                        <!-- Data controls container: hidden when Dev is off -->
                        <div id="data-controls" style="display:flex; gap:8px; align-items:center;">
                            <label for="data-selector" style="font-size:13px; color: #4a5568; font-weight:500;">Data:</label>
                            <select id="data-selector" aria-label="Data selection" style="padding:8px 12px; border-radius:4px; border:1px solid #e2e8f0; background:white; color:#4a5568; cursor:pointer; font-size:13px; font-weight:500;">
                                <option value="budget">Budget</option>
                                <option value="actual" selected>Actual</option>
                                <option value="forecast">Forecast</option>
                            </select>
                        </div>
                    </div>
                    <span id="input-dir-status" class="status-text"></span>
                    <div id="loading-status" class="loading-status"></div>
                </div>
                
                <!-- Right side: File status indicators -->
                <div class="file-status-grid" style="flex: 0 0 auto; grid-template-columns: auto; gap: 8px;">
                    <div class="file-status-item clickable" data-file="tb2425" style="min-width: 240px;">
                        <span class="file-label">TB 2024+2025</span>
                        <span id="status-tb2425" class="status-indicator">üëÅÔ∏è</span>
                    </div>
                </div>
            </div>
            
            <!-- Data Preview Section -->
            <div id="data-preview" style="display: none; margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 4px; max-height: 400px; overflow: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong id="preview-title" style="font-size: 13px;"></strong>
                    <button id="close-preview" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #666;">√ó</button>
                </div>
                <div id="preview-content"></div>
            </div>

            <!-- Validation Messages -->
            <div id="validation-messages" class="validation-messages" style="display: none;">
                <div id="validation-errors" class="validation-errors"></div>
                <div id="validation-warnings" class="validation-warnings"></div>
            </div>
        </div>

        <!-- Statement Display Section -->
        <div id="statement-section" class="section" style="display: none;">
            <h2>Statements</h2>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <label style="font-size: 13px; color: #4a5568; font-weight: 500;">Statement:</label>
                    <select id="statement-selector" style="padding: 8px 16px; border-radius: 4px; border: 1px solid #e2e8f0; background: white; color: #4a5568; cursor: pointer; font-size: 13px; font-weight: 500;">
                        <option value="balance-sheet">Balance Sheet</option>
                        <option value="income-statement">Income Statement</option>
                        <option value="cash-flow">Cash Flow</option>
                    </select>
                    <label style="font-size: 13px; color: #4a5568; font-weight: 500;">Columns:</label>
                    <select id="placeholder-dropdown" style="padding: 8px 16px; border-radius: 4px; border: 1px solid #e2e8f0; background: white; color: #4a5568; cursor: pointer; font-size: 13px; font-weight: 500;">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="11">11</option>
                        <option value="12">12</option>
                    </select>
                </div>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <!-- Detail level control moved to table header -->
                </div>
            </div>
            <div id="statement-display" class="statement-display"></div>
            
            <!-- Export Controls -->
            <div class="export-controls">
                <button id="export-all" class="btn btn-secondary">Export All</button>
                <span id="export-status" class="status-text"></span>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CONSTANTS AND CONFIGURATION
        // ============================================================================
        
        // Application Configuration
        const APP_CONFIG = {
            YEARS: ['2024', '2025'],
            PERIODS_PER_YEAR: 12,
            DEFAULT_YEAR: '2024',
            DEFAULT_PERIOD: 'all',
            VERSION: '2.8.0'
        };
        
        // Statement Types
        const STATEMENT_TYPES = {
            BALANCE_SHEET: 'BS',
            INCOME_STATEMENT: 'IS',
            CASH_FLOW: 'CF'
        };

        // Excel Column Indices (1-based)
        const EXCEL_COLUMNS = {
            STATEMENT_TYPE: 4,
            CODE1: 5,
            NAME1: 6,
            CODE2: 7,
            NAME2: 8,
            CODE3: 9,
            NAME3: 10,
            ACCOUNT_CODE: 11,
            ACCOUNT_DESCRIPTION: 12
        };

        // Export Configuration
        const EXPORT_CONFIG = {
            // Excel Colors (ARGB format)
            COLORS: {
                HEADER: 'FF007bff',           // Blue header background
                METRIC_HIGHLIGHT: 'FFFFE599', // Yellow highlight for metrics
                WHITE: 'FFFFFFFF',            // White text
                CATEGORY_HEADER: 'FFE9ECEF'   // Light gray for categories
            },
            
            // Number Formats
            NUMBER_FORMAT: '#,##0',           // Whole numbers with thousand separator
            
            // Column Widths (in Excel units)
            COLUMN_WIDTHS: {
                LINE_ITEM: 35,                // Width for line item descriptions
                AMOUNT: 15,                   // Width for amount columns
                METADATA_LABEL: 25,           // Width for metadata labels
                METADATA_VALUE: 50            // Width for metadata values
            },
            
            // Font Sizes (in points)
            FONT_SIZES: {
                TITLE: 14,                    // Metadata sheet title
                HEADER: 12,                   // Table headers
                NORMAL: 11                    // Regular content
            }
        };

        // Validation Configuration
        const VALIDATION_CONFIG = {
            // Balance Sheet tolerance for accounting equation
            BALANCE_TOLERANCE: 0.01,          // Maximum acceptable imbalance
            
            // File size warning threshold (in bytes)
            LARGE_FILE_THRESHOLD: 10 * 1024 * 1024, // 10 MB
            
            // Required columns for trial balance files
            REQUIRED_COLUMNS: [
                'account_code',
                'account_description',
                'statement_type',
                'code1',
                'name1'
            ]
        };

        // UI Configuration
        const UI_CONFIG = {
            // Status Message Colors
            STATUS_COLORS: {
                INFO: '#007bff',              // Blue for info messages
                ERROR: '#dc3545',             // Red for errors
                SUCCESS: '#28a745'            // Green for success
            },
            
            // Status Message Icons
            STATUS_ICONS: {
                INFO: '',                     // No icon for info
                ERROR: '‚ùå ',                 // Red X for errors
                SUCCESS: '‚úÖ '                // Green check for success
            },
            
            // Timing
            MESSAGE_TIMEOUT: 3000,            // Auto-clear messages after 3 seconds
            STATEMENT_REGEN_TIMEOUT: 1000,    // Max time for statement regeneration
            
            // Preview
            PREVIEW_ROW_LIMIT: 20             // Number of rows to show in preview
        };

        // Category Definitions for Financial Statements
        const CATEGORY_DEFINITIONS = {
            // Asset Categories (for Total Assets calculation)
            ASSETS: [
                'immateri√´le vaste activa',   // Intangible fixed assets
                'materi√´le vaste activa',     // Tangible fixed assets
                'voorraden',                  // Inventory
                'vorderingen',                // Receivables
                'liquide middelen'            // Cash and equivalents
            ],
            
            // Liability Categories
            LIABILITIES: [
                'schuld',                     // Debts
                'voorziening',                // Provisions
                'passiva'                     // Liabilities
            ],
            
            // Equity Categories
            EQUITY: [
                'eigen vermogen',             // Equity
                'equity'                      // Equity (English)
            ],
            
            // Cash Categories (for Cash Flow Statement)
            CASH: [
                'liquide middelen',           // Cash and equivalents
                'cash',                       // Cash (English)
                'bank'                        // Bank accounts
            ]
        };

        // UI Statement Type Constants (for rendering and display logic)
        const UI_STATEMENT_TYPES = {
            BALANCE_SHEET: 'balance-sheet',
            INCOME_STATEMENT: 'income-statement',
            CASH_FLOW: 'cash-flow'
        };

        // Year Configuration Helper (supports 2, 3, or more years dynamically)
        const YEAR_CONFIG = {
            // Get all years from APP_CONFIG
            get years() {
                return APP_CONFIG.YEARS;
            },

            // Get number of years
            get yearCount() {
                return APP_CONFIG.YEARS.length;
            },

            // Get specific year by index (0-based)
            getYear(index) {
                return APP_CONFIG.YEARS[index];
            },

            // Get column name for a year
            getAmountColumn(year) {
                return `amount_${year}`;
            },

            // Get all amount column names
            get amountColumns() {
                return APP_CONFIG.YEARS.map(year => `amount_${year}`);
            },

            // Get year pairs for variance calculations (adjacent years)
            get yearPairs() {
                const pairs = [];
                for (let i = 0; i < APP_CONFIG.YEARS.length - 1; i++) {
                    pairs.push({
                        prior: APP_CONFIG.YEARS[i],
                        current: APP_CONFIG.YEARS[i + 1],
                        priorColumn: `amount_${APP_CONFIG.YEARS[i]}`,
                        currentColumn: `amount_${APP_CONFIG.YEARS[i + 1]}`,
                        varianceColumn: `variance_${APP_CONFIG.YEARS[i]}_${APP_CONFIG.YEARS[i + 1]}`
                    });
                }
                return pairs;
            },

            // Get default period value for a year
            getDefaultPeriod(year) {
                return `${year}-all`;
            }
        };

        // Configuration (loaded from config.json)
        let config = null;

        // ============================================================================
        // UTILITY CLASSES
        // ============================================================================

        // CategoryMatcher - Utility for matching categories against patterns
        class CategoryMatcher {
            /**
             * Check if a category name matches any of the given patterns
             * @param {string} categoryName - The category name to check
             * @param {string[]} patterns - Array of patterns to match
             * @param {string[]} excludePatterns - Optional patterns to exclude
             * @returns {boolean} True if matches any pattern and not excluded
             */
            static matches(categoryName, patterns, excludePatterns = []) {
                if (!categoryName) return false;

                const lower = categoryName.toLowerCase();
                const hasMatch = patterns.some(pattern => lower.includes(pattern));
                const hasExclude = excludePatterns.length > 0 &&
                                  excludePatterns.some(pattern => lower.includes(pattern));

                return hasMatch && !hasExclude;
            }

            // Balance Sheet category matchers
            static isAsset(categoryName) {
                return CATEGORY_DEFINITIONS.ASSETS.some(cat =>
                    this.matches(categoryName, [cat])
                );
            }

            static isLiability(categoryName) {
                return CATEGORY_DEFINITIONS.LIABILITIES.some(cat =>
                    this.matches(categoryName, [cat])
                );
            }

            static isEquity(categoryName) {
                return CATEGORY_DEFINITIONS.EQUITY.some(cat =>
                    this.matches(categoryName, [cat])
                );
            }

            // Income Statement category matchers
            static isRevenue(categoryName) {
                return this.matches(categoryName, ['omzet'], ['kostprijs']);
            }

            static isCOGS(categoryName) {
                return this.matches(categoryName, ['kostprijs']);
            }

            static isOperatingExpense(categoryName) {
                return this.matches(categoryName, ['kosten', 'bedrijf']);
            }

            static isOtherIncome(categoryName) {
                return this.matches(categoryName, ['overige', 'opbrengst']);
            }

            static isTax(categoryName) {
                return this.matches(categoryName, ['belasting', 'tax']);
            }

            // Cash Flow category matchers
            static isDepreciation(categoryName) {
                return this.matches(categoryName, ['afschrijving', 'depreciation', 'amortization']);
            }

            static isCurrentAsset(categoryName) {
                return this.matches(categoryName, ['vlottende', 'current']);
            }

            static isFixedAsset(categoryName) {
                return this.matches(categoryName, ['vaste activa', 'fixed assets']);
            }

            static isLongTermLiability(categoryName) {
                return this.matches(categoryName, ['eigen vermogen', 'equity', 'langlopend', 'long-term']);
            }

            // UI rendering helpers
            static isLiabilityOrEquity(categoryName) {
                return this.matches(categoryName, ['passiva', 'vermogen', 'liabilit', 'equity', 'schuld']);
            }
        }

        // VarianceCalculator - Utility for calculating variances and percentages
        class VarianceCalculator {
            /**
             * Calculate variance amount and percentage between two values
             * @param {number} current - Current period value
             * @param {number} prior - Prior period value
             * @returns {{amount: number, percent: number}} Variance amount and percent
             */
            static calculate(current, prior) {
                const amount = current - prior;
                const percent = prior !== 0 ? (amount / Math.abs(prior)) * 100 : 0;
                return { amount, percent };
            }

            /**
             * Calculate variance for a metric object with year keys
             * @param {Object} metric - Object with year keys (e.g., {'2024': 100, '2025': 120})
             * @param {string} yearCurrent - Current year key
             * @param {string} yearPrior - Prior year key
             * @returns {{amount: number, percent: number}} Variance amount and percent
             */
            static calculateForMetric(metric, yearCurrent, yearPrior) {
                return this.calculate(metric[yearCurrent] || 0, metric[yearPrior] || 0);
            }

            /**
             * Calculate variance for a row with amount_2024 and amount_2025 properties
             * @param {Object} row - Row object with amount_2024 and amount_2025
             * @returns {{amount: number, percent: number}} Variance amount and percent
             */
            static calculateForRow(row) {
                return this.calculate(row.amount_2025 || 0, row.amount_2024 || 0);
            }
        }

        // ============================================================================
        // DATA MANAGEMENT CLASSES
        // ============================================================================

        // DataStore class for state management (Singleton pattern)
        class DataStore {
            constructor() {
                if (DataStore.instance) {
                    return DataStore.instance;
                }
                
                this.factTables = {}; // Store FactTables by period and type: {2024: {movements: table, balances: table}, 2025: {...}}
                this.combinedMovements = null; // Combined movements table for both years
                
                DataStore.instance = this;
            }

            // Store FactTable for a specific period and type
            setFactTable(table, period, type = 'movements') {
                if (!this.factTables[period]) {
                    this.factTables[period] = {};
                }
                this.factTables[period][type] = table;
                console.log(`FactTable ${type} for ${period} stored (${table.numRows()} rows)`);
            }

            // Retrieve FactTable for a specific period and type
            getFactTable(period, type = 'movements') {
                return this.factTables[period]?.[type] || null;
            }

            // Shorthand: Get movements table for a period
            getMovementsTable(period) {
                return this.getFactTable(period, 'movements');
            }

            // Shorthand: Get balances table for a period
            getBalancesTable(period) {
                return this.getFactTable(period, 'balances');
            }

            // Get row counts for verification
            getRowCounts(period) {
                const movements = this.getMovementsTable(period);
                const balances = this.getBalancesTable(period);
                return {
                    movements: movements ? movements.numRows() : 0,
                    balances: balances ? balances.numRows() : 0
                };
            }

            // Store Hierarchy Table
            setHierarchyTable(table) {
                this.hierarchyTable = table;
                console.log('Hierarchy Table stored');
            }

            // Retrieve Hierarchy Table
            getHierarchyTable() {
                return this.hierarchyTable;
            }



            // Get all loaded periods
            getAllPeriods() {
                return Object.keys(this.factTables);
            }

            // Store combined movements table
            setCombinedMovements(table) {
                this.combinedMovements = table;
                console.log(`Combined movements table stored (${table.numRows()} rows)`);
            }

            // Retrieve combined movements table
            getCombinedMovements() {
                return this.combinedMovements;
            }

            // Check if all required data is loaded
            isDataComplete() {
                const has2024Movements = this.factTables['2024']?.movements;
                const has2024Balances = this.factTables['2024']?.balances;
                const has2025Movements = this.factTables['2025']?.movements;
                const has2025Balances = this.factTables['2025']?.balances;
                const hasBothPeriods = has2024Movements && has2024Balances && has2025Movements && has2025Balances;
                return hasBothPeriods && this.combinedMovements;
            }

            // Clear all data
            clear() {
                this.factTables = {};
                this.combinedMovements = null;
                console.log('DataStore cleared');
            }
        }
        
        // Load configuration file
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                config = await response.json();
                console.log('Configuration loaded:', config);
                return config;
            } catch (error) {
                console.error('Error loading config:', error);
                // Use default configuration
                config = {
                    inputFiles: {
                        trialBalance2024: "2024_BalansenWinstverliesperperiode.xlsx",
                        trialBalance2025: "2025_BalansenWinstverliesperperiode.xlsx",
                        dates: "DimDates.xlsx",
                        format: "format.xlsx"
                    },
                    outputFiles: {
                        balanceSheet: "balance_sheet.xlsx",
                        incomeStatement: "income_statement.xlsx",
                        cashFlowStatement: "cash_flow_statement.xlsx",
                        allStatements: "financial_statements_all.xlsx"
                    },
                    directories: {
                        input: "input",
                        output: "output"
                    }
                };
                return config;
            }
        }

        // DataLoader class for Excel file parsing with directory access
        class DataLoader {
            constructor() {
                this.inputDirHandle = null;
                this.outputDirHandle = null;
                
                // Dutch month names to period numbers mapping
                this.MONTH_MAP = {
                    'januari': 1,
                    'februari': 2,
                    'maart': 3,
                    'april': 4,
                    'mei': 5,
                    'juni': 6,
                    'juli': 7,
                    'augustus': 8,
                    'september': 9,
                    'oktober': 10,
                    'november': 11,
                    'december': 12
                };
            }

            // Request access to input directory
            async selectInputDirectory() {
                try {
                    // Note: The File System Access API doesn't support relative paths or specific subdirectories
                    // as starting points. We can only use well-known directories like 'documents', 'desktop', etc.
                    // The user will need to navigate to the 'input' directory manually.
                    this.inputDirHandle = await window.showDirectoryPicker({
                        mode: 'read',
                        startIn: 'documents',
                        id: 'financial-statement-input' // Helps browser remember the last location
                    });
                    console.log('Input directory selected:', this.inputDirHandle.name);
                    
                    // Provide helpful feedback if user didn't select 'input' directory
                    if (this.inputDirHandle.name.toLowerCase() !== 'input') {
                        console.warn('Note: Expected directory name is "input". Selected:', this.inputDirHandle.name);
                    }
                    
                    return this.inputDirHandle;
                } catch (error) {
                    console.error('Error selecting input directory:', error);
                    throw new Error('Failed to select input directory');
                }
            }

            // Request access to output directory
            async selectOutputDirectory() {
                try {
                    this.outputDirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });
                    console.log('Output directory selected:', this.outputDirHandle.name);
                    return this.outputDirHandle;
                } catch (error) {
                    console.error('Error selecting output directory:', error);
                    throw new Error('Failed to select output directory');
                }
            }

            // Read file from input directory
            async readFileFromDirectory(filename) {
                if (!this.inputDirHandle) {
                    throw new Error('Input directory not selected. Please select input directory first.');
                }

                try {
                    const fileHandle = await this.inputDirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    return file;
                } catch (error) {
                    console.error(`Error reading file ${filename}:`, error);
                    throw new Error(`File not found: ${filename}`);
                }
            }

            // Validate required columns in Excel data
            validateColumns(data, requiredColumns) {
                if (!data || data.length === 0) {
                    throw new Error('File is empty or invalid');
                }

                const firstRow = data[0];
                const actualColumns = Object.keys(firstRow);
                const missingColumns = requiredColumns.filter(col => !actualColumns.includes(col));

                if (missingColumns.length > 0) {
                    throw new Error(`File missing required columns: ${missingColumns.join(', ')}`);
                }

                return true;
            }

            // Map month name and year to period number
            mapMonthToPeriod(columnName, year) {
                const lowerCol = String(columnName).toLowerCase();
                
                // Check for "Voorafgaandejournaalposten" - map to period 12 (December)
                if (lowerCol.includes('voorafgaandejournaalposten') || lowerCol.includes('voorafgaande')) {
                    if (lowerCol.includes(year)) {
                        return {
                            period: 12,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for month patterns (e.g., "januari2024", "februari2024")
                for (const [monthName, periodNum] of Object.entries(this.MONTH_MAP)) {
                    if (lowerCol.includes(monthName) && lowerCol.includes(year)) {
                        return {
                            period: periodNum,
                            year: parseInt(year),
                            type: 'movement'
                        };
                    }
                }
                
                // Check for balance indicators
                if (lowerCol.includes('saldo') || lowerCol.includes('balance')) {
                    return {
                        period: 12, // End of year
                        year: parseInt(year),
                        type: 'balance'
                    };
                }
                
                return null;
            }

            // Identify period columns from headers
            identifyPeriodColumns(headers, year) {
                const movements = [];
                const balances = [];
                
                headers.forEach((header, index) => {
                    if (!header) return;
                    
                    const mapping = this.mapMonthToPeriod(header, year);
                    if (mapping) {
                        if (mapping.type === 'movement') {
                            movements.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        } else if (mapping.type === 'balance') {
                            balances.push({
                                columnIndex: index,
                                period: mapping.period,
                                columnName: header
                            });
                        }
                    }
                });
                
                return { movements, balances };
            }

            // Transform wide format data to long format
            transformWideToLong(worksheet, year) {
                const movements = [];
                const balances = [];
                
                // Get headers from first row
                const headers = [];
                const headerRow = worksheet.getRow(1);
                headerRow.eachCell((cell, colNumber) => {
                    headers[colNumber] = cell.value;
                });
                
                // Identify period columns
                const periodColumns = this.identifyPeriodColumns(headers, year);
                
                console.log(`Found ${periodColumns.movements.length} movement columns and ${periodColumns.balances.length} balance columns for ${year}`);
                
                // Process each data row
                worksheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // Skip header row
                    
                    const accountCode = row.getCell(EXCEL_COLUMNS.ACCOUNT_CODE).value;
                    const accountDescription = row.getCell(EXCEL_COLUMNS.ACCOUNT_DESCRIPTION).value;
                    
                    if (!accountCode) return;
                    
                    // Extract hierarchy columns
                    const statementType = row.getCell(EXCEL_COLUMNS.STATEMENT_TYPE).value;
                    const level1Code = row.getCell(EXCEL_COLUMNS.CODE1).value;
                    const level1Label = row.getCell(EXCEL_COLUMNS.NAME1).value;
                    const level2Code = row.getCell(EXCEL_COLUMNS.CODE2).value;
                    const level2Label = row.getCell(EXCEL_COLUMNS.NAME2).value;
                    const level3Code = row.getCell(EXCEL_COLUMNS.CODE3).value;
                    const level3Label = row.getCell(EXCEL_COLUMNS.NAME3).value;
                    
                    // Determine statement type
                    let stmtType = STATEMENT_TYPES.INCOME_STATEMENT; // Default
                    if (statementType === 'Balans') {
                        stmtType = STATEMENT_TYPES.BALANCE_SHEET;
                    } else if (statementType === 'Winst & verlies') {
                        stmtType = STATEMENT_TYPES.INCOME_STATEMENT;
                    }
                    
                    // Determine Code0 and Name0 based on code1
                    let code0 = '';
                    let name0 = '';
                    const level1CodeNum = parseInt(level1Code);

                    if ([0, 10, 20].includes(level1CodeNum)) {
                        code0 = 'A';
                        name0 = 'vaste activa';
                    } else if ([30, 40, 50].includes(level1CodeNum)) {
                        code0 = 'A';
                        name0 = 'vlottende activa';
                    } else if (level1CodeNum === 60) {
                        code0 = 'L';
                        name0 = 'eigen vermogen';
                    } else if ([65, 70].includes(level1CodeNum)) {
                        code0 = 'L';
                        name0 = 'lange termijn schulden';
                    } else if ([80, 90].includes(level1CodeNum)) {
                        code0 = 'L';
                        name0 = 'korte termijn schulden';
                    }

                    // Create base row with hierarchy
                    const baseRow = {
                        statement_type: stmtType,
                        code0: code0,
                        name0: name0,
                        code1: level1Code !== null && level1Code !== undefined ? String(level1Code) : '',
                        name1: (level1Label ?? '').toString(),
                        code2: level2Code !== null && level2Code !== undefined ? String(level2Code) : '',
                        name2: (level2Label ?? level1Label ?? '').toString(),
                        code3: level3Code !== null && level3Code !== undefined ? String(level3Code) : '',
                        name3: level3Label ?? '',
                        account_code: String(accountCode),
                        account_description: String(accountDescription ?? '')
                    };
                    
                    // Process movement columns
                    periodColumns.movements.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            movements.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                movement_amount: Number(value)
                            });
                        }
                    });
                    
                    // Process balance columns
                    periodColumns.balances.forEach(col => {
                        const value = row.getCell(col.columnIndex).value;
                        
                        // Only include non-zero and non-null values (sparse representation)
                        if (value !== null && value !== undefined && value !== 0) {
                            balances.push({
                                ...baseRow,
                                period: col.period,
                                year: parseInt(year),
                                balance_amount: Number(value)
                            });
                        }
                    });
                });
                
                console.log(`Transformed to ${movements.length} movement rows and ${balances.length} balance rows`);
                
                return { movements, balances };
            }

            // Load trial balance amounts for a specific period
            async loadTrialBalance(period) {
                const filename = period === '2024' 
                    ? config.inputFiles.trialBalance2024 
                    : config.inputFiles.trialBalance2025;

                try {
                    // Validate period parameter
                    if (!period || (period !== '2024' && period !== '2025')) {
                        throw new Error(`Invalid period: ${period}. Must be '2024' or '2025'.`);
                    }
                    
                    // Read file
                    const file = await this.readFileFromDirectory(filename);
                    
                    // Validate file size (warn if > threshold)
                    if (file.size > VALIDATION_CONFIG.LARGE_FILE_THRESHOLD) {
                        console.warn(`Large file detected: ${filename} (${(file.size / 1024 / 1024).toFixed(2)} MB). Loading may take longer.`);
                    }
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    // Validate workbook has worksheets
                    if (!workbook.worksheets || workbook.worksheets.length === 0) {
                        throw new Error(`File ${filename} contains no worksheets`);
                    }
                    
                    const worksheet = workbook.worksheets[0];
                    
                    // Validate worksheet has data
                    if (!worksheet || worksheet.rowCount < 2) {
                        throw new Error(`File ${filename} is empty or has insufficient data (needs at least header + 1 data row)`);
                    }
                    
                    console.log(`Transforming ${filename} from wide to long format...`);
                    console.log(`  - Worksheet: ${worksheet.name}`);
                    console.log(`  - Rows: ${worksheet.rowCount}, Columns: ${worksheet.columnCount}`);
                    
                    // Transform wide format to long format
                    const { movements, balances } = this.transformWideToLong(worksheet, period);
                    
                    // Validate transformation results
                    if (!movements || movements.length === 0) {
                        console.warn(`No movements found in ${filename}. This may indicate a data issue.`);
                    }
                    
                    // Convert arrays to Arquero tables
                    const movementsTable = aq.from(movements);
                    const balancesTable = aq.from(balances);
                    
                    console.log(`Trial Balance ${period} loaded successfully:`);
                    console.log(`  - Movements: ${movementsTable.numRows()} rows`);
                    console.log(`  - Balances: ${balancesTable.numRows()} rows`);
                    
                    // Validate required columns exist
                    const requiredColumns = ['account_code', 'statement_type', 'code1', 'name1'];
                    const movementColumns = movementsTable.columnNames();
                    const missingColumns = requiredColumns.filter(col => !movementColumns.includes(col));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`Transformed data missing required columns: ${missingColumns.join(', ')}`);
                    }
                    
                    return {
                        movements: movementsTable,
                        balances: balancesTable
                    };

                } catch (error) {
                    console.error(`Error loading trial balance for ${period}:`, error);
                    
                    // Enhance error message for common issues
                    if (error.message.includes('getFileHandle')) {
                        throw new Error(`File not found: ${filename}. Please ensure the file exists in the selected directory.`);
                    } else if (error.message.includes('xlsx.load')) {
                        throw new Error(`Failed to parse ${filename}. Please ensure it is a valid Excel file (.xlsx).`);
                    } else {
                        throw error;
                    }
                }
            }


        }

        // StatementGenerator class for generating financial statements
        class StatementGenerator {
            constructor(dataStore) {
                this.dataStore = dataStore;
                this.unmappedAccounts = [];
            }

            // Helper: Calculate variance percentage
            calculateVariancePercent(amt2024, amt2025) {
                return amt2024 !== 0 ? ((amt2025 - amt2024) / Math.abs(amt2024)) * 100 : 0;
            }

            // Helper: Validate required data is loaded
            validateRequiredData() {
                const combinedMovements = this.dataStore.getCombinedMovements();
                
                if (!combinedMovements) {
                    throw new Error('Required data not loaded');
                }
                
                return combinedMovements;
            }

            // Helper: Calculate variance columns
            deriveVarianceColumns(combined) {
                // Note: Arquero requires static column names in derive operations
                // We use amount_2024/amount_2025 as the column identifiers
                return combined.derive({
                    amount_2024: d => d.amount_2024 || 0,
                    amount_2025: d => d.amount_2025 || 0,
                    variance_amount: d => (d.amount_2025 || 0) - (d.amount_2024 || 0),
                    variance_percent: d => {
                        const amt1 = d.amount_2024 || 0;
                        const amt2 = d.amount_2025 || 0;
                        return amt1 !== 0 ? ((amt2 - amt1) / Math.abs(amt1)) * 100 : 0;
                    }
                });
            }

            // Helper: Calculate category totals
            calculateCategoryTotals(combined) {
                // Note: Arquero requires static column names in rollup operations
                // We use amount_2024/amount_2025 as the column identifiers
                return combined
                    .groupby('name1')
                    .rollup({
                        amount_2024: d => aq.op.sum(d.amount_2024),
                        amount_2025: d => aq.op.sum(d.amount_2025),
                        variance_amount: d => aq.op.sum(d.variance_amount),
                        variance_percent: d => {
                            const total1 = aq.op.sum(d.amount_2024);
                            const total2 = aq.op.sum(d.amount_2025);
                            return total1 !== 0 ? ((total2 - total1) / Math.abs(total1)) * 100 : 0;
                        }
                    });
            }

            // Detect unmapped accounts
            detectUnmappedAccounts() {
                try {
                    const factTable2024 = this.dataStore.getFactTable('2024');
                    const factTable2025 = this.dataStore.getFactTable('2025');
                    const hierarchyTable = this.dataStore.getHierarchyTable();

                    if (!factTable2024 || !factTable2025 || !hierarchyTable) {
                        return [];
                    }

                    // Get all account codes from hierarchy
                    const hierarchyAccounts = new Set(
                        hierarchyTable.array('account_code')
                    );

                    // Check 2024 accounts
                    const accounts2024 = factTable2024.array('account_code');
                    const unmapped2024 = accounts2024.filter(code => !hierarchyAccounts.has(code));

                    // Check 2025 accounts
                    const accounts2025 = factTable2025.array('account_code');
                    const unmapped2025 = accounts2025.filter(code => !hierarchyAccounts.has(code));

                    // Combine and deduplicate
                    const allUnmapped = [...new Set([...unmapped2024, ...unmapped2025])];
                    
                    this.unmappedAccounts = allUnmapped;
                    
                    if (allUnmapped.length > 0) {
                        console.warn(`Found ${allUnmapped.length} unmapped accounts:`, allUnmapped);
                    }

                    return allUnmapped;

                } catch (error) {
                    console.error('Error detecting unmapped accounts:', error);
                    return [];
                }
            }

            // Validate data completeness
            validateData() {
                const errors = [];
                const warnings = [];

                // Check if combined movements table is loaded
                const combinedMovements = this.dataStore.getCombinedMovements();
                
                if (!combinedMovements) {
                    errors.push('Trial Balance data is not loaded');
                }



                return { errors, warnings, unmappedAccounts: [] };
            }

            // Consolidated statement generation method
            generateStatement(statementType, options = {}) {
                try {
                    const combinedMovements = this.validateRequiredData();

                    // Filter for specific statement type
                    let filtered = combinedMovements.params({ statementType }).filter(d => d.statement_type === statementType);

                    // Apply period filters if specified
                    // Parse year-period combinations (format: "2024-all", "2024-1", "2024-Q1", "2025-6", etc.)
                    const year1 = YEAR_CONFIG.getYear(0);
                    const year2 = YEAR_CONFIG.getYear(1);
                    const col1 = YEAR_CONFIG.getAmountColumn(year1);
                    const col2 = YEAR_CONFIG.getAmountColumn(year2);

                    const periodYear1Value = options[`period${year1}`] || `${year1}-all`;
                    const periodYear2Value = options[`period${year2}`] || `${year2}-all`;

                    // Helper function to parse period value (handles 'all', quarters 'Q1-Q4', and individual periods)
                    const parsePeriod = (periodStr) => {
                        if (periodStr === 'all') return 999;
                        if (periodStr.startsWith('Q')) {
                            const quarter = parseInt(periodStr.substring(1));
                            return quarter * 3; // Q1=3, Q2=6, Q3=9, Q4=12
                        }
                        return parseInt(periodStr);
                    };

                    // Parse first column selection (year-period)
                    const [yearStr1, periodStr1] = periodYear1Value.split('-');
                    const yearInt1 = parseInt(yearStr1);
                    const periodInt1 = parsePeriod(periodStr1);

                    // Parse second column selection (year-period)
                    const [yearStr2, periodStr2] = periodYear2Value.split('-');
                    const yearInt2 = parseInt(yearStr2);
                    const periodInt2 = parsePeriod(periodStr2);

                    // Filter data based on selected year-period combinations
                    if (periodYear1Value !== `${year1}-all` || periodYear2Value !== `${year2}-all`) {
                        filtered = filtered
                            .params({
                                yearInt1: yearInt1,
                                periodInt1: periodInt1,
                                yearInt2: yearInt2,
                                periodInt2: periodInt2
                            })
                            .filter(d =>
                                (d.year === yearInt1 && d.period <= periodInt1) ||
                                (d.year === yearInt2 && d.period <= periodInt2)
                            );
                    }

                    // Use conditional aggregation to get both columns in one pass (no join needed!)
                    // Include level codes for proper sorting
                    // For Income Statement, flip the sign to show revenue as positive
                    // Note: Arquero requires static column names in rollup operations.
                    // We keep amount_2024/amount_2025 as column identifiers, but they represent
                    // the dynamically selected year-period combinations via col1/col2 references.
                    const signMultiplier = statementType === STATEMENT_TYPES.INCOME_STATEMENT ? -1 : 1;

                    const aggregated = filtered
                        .params({
                            col1Year: yearInt1,
                            col2Year: yearInt2,
                            signMult: signMultiplier
                        })
                        .groupby('name1', 'name2', 'code0', 'name0', 'code1', 'code2', 'code3')
                        .rollup({
                            amount_2024: d => aq.op.sum(d.year === col1Year ? d.movement_amount * signMult : 0),
                            amount_2025: d => aq.op.sum(d.year === col2Year ? d.movement_amount * signMult : 0)
                        });

                    console.log('Columns after aggregation:', aggregated.columnNames());

                    // Add ordering if specified - sort by level codes for proper order (all 3 levels)
                    const ordered = options.orderBy ? aggregated.orderby('code1', 'code2', 'code3') : aggregated;
                    
                    // Calculate variances
                    const withVariances = this.deriveVarianceColumns(ordered);

                    // Calculate category totals
                    const categoryTotals = this.calculateCategoryTotals(withVariances);

                    // Build result object
                    const result = {
                        details: withVariances,
                        totals: categoryTotals
                    };

                    // Add statement-specific calculations
                    if (options.calculateMetrics) {
                        result.metrics = options.calculateMetrics(categoryTotals);
                    }

                    if (options.validateBalance) {
                        const validation = options.validateBalance(categoryTotals);
                        Object.assign(result, validation);
                    }

                    return result;

                } catch (error) {
                    const statementName = options.name || 'Statement';
                    console.error(`Error generating ${statementName}:`, error);
                    throw error;
                }
            }

            // Generate Balance Sheet
            generateBalanceSheet(options = {}) {
                const year1 = YEAR_CONFIG.getYear(0);
                const year2 = YEAR_CONFIG.getYear(1);

                return this.generateStatement(STATEMENT_TYPES.BALANCE_SHEET, {
                    name: 'Balance Sheet',
                    [`period${year1}`]: options[`period${year1}`],
                    [`period${year2}`]: options[`period${year2}`],
                    validateBalance: (categoryTotals) => {
                        // Use latest year for balance validation
                        const latestYear = YEAR_CONFIG.getYear(YEAR_CONFIG.yearCount - 1);
                        const latestCol = YEAR_CONFIG.getAmountColumn(latestYear);

                        const totals = categoryTotals.objects();
                        let totalAssets = 0, totalLiabilities = 0, totalEquity = 0;

                        totals.forEach(row => {
                            if (CategoryMatcher.isAsset(row.name1)) {
                                totalAssets += row[latestCol] || 0;
                            } else if (CategoryMatcher.isLiability(row.name1)) {
                                totalLiabilities += row[latestCol] || 0;
                            } else if (CategoryMatcher.isEquity(row.name1)) {
                                totalEquity += row[latestCol] || 0;
                            }
                        });

                        const imbalance = Math.abs(totalAssets - (totalLiabilities + totalEquity));
                        if (imbalance > VALIDATION_CONFIG.BALANCE_TOLERANCE) {
                            console.warn(`Balance Sheet imbalance: ${imbalance.toFixed(2)}`);
                            console.warn(`Total Assets: ${totalAssets.toFixed(2)}`);
                            console.warn(`Total Liabilities: ${totalLiabilities.toFixed(2)}`);
                            console.warn(`Total Equity: ${totalEquity.toFixed(2)}`);
                        }

                        return {
                            balanced: imbalance <= VALIDATION_CONFIG.BALANCE_TOLERANCE,
                            imbalance: imbalance
                        };
                    }
                });
            }

            // Generate Income Statement
            generateIncomeStatement(options = {}) {
                const year1 = YEAR_CONFIG.getYear(0);
                const year2 = YEAR_CONFIG.getYear(1);

                return this.generateStatement(STATEMENT_TYPES.INCOME_STATEMENT, {
                    name: 'Income Statement',
                    orderBy: true,
                    [`period${year1}`]: options[`period${year1}`],
                    [`period${year2}`]: options[`period${year2}`],
                    calculateMetrics: (categoryTotals) => {
                        // Use YEAR_CONFIG for dynamic year references
                        const year1 = YEAR_CONFIG.getYear(0);
                        const year2 = YEAR_CONFIG.getYear(1);
                        const col1 = YEAR_CONFIG.getAmountColumn(year1);
                        const col2 = YEAR_CONFIG.getAmountColumn(year2);

                        const totals = categoryTotals.objects();
                        let revenue1 = 0, revenue2 = 0;
                        let cogs1 = 0, cogs2 = 0;
                        let opex1 = 0, opex2 = 0;
                        let otherIncome1 = 0, otherIncome2 = 0;
                        let taxes1 = 0, taxes2 = 0;

                        totals.forEach(row => {
                            // Revenue (Netto-omzet, Omzet, etc.)
                            if (CategoryMatcher.isRevenue(row.name1)) {
                                revenue1 += row[col1] || 0;
                                revenue2 += row[col2] || 0;
                            }
                            // Cost of Goods Sold (Kostprijs van de omzet)
                            else if (CategoryMatcher.isCOGS(row.name1)) {
                                cogs1 += row[col1] || 0;
                                cogs2 += row[col2] || 0;
                            }
                            // Operating Expenses (Bedrijfskosten, Kosten, etc.)
                            else if (CategoryMatcher.isOperatingExpense(row.name1)) {
                                opex1 += row[col1] || 0;
                                opex2 += row[col2] || 0;
                            }
                            // Other Income (Overige opbrengsten, etc.)
                            else if (CategoryMatcher.isOtherIncome(row.name1)) {
                                otherIncome1 += row[col1] || 0;
                                otherIncome2 += row[col2] || 0;
                            }
                            // Taxes (Belastingen)
                            else if (CategoryMatcher.isTax(row.name1)) {
                                taxes1 += row[col1] || 0;
                                taxes2 += row[col2] || 0;
                            }
                        });

                        const grossProfit1 = revenue1 + cogs1;
                        const grossProfit2 = revenue2 + cogs2;
                        const operatingIncome1 = grossProfit1 + opex1;
                        const operatingIncome2 = grossProfit2 + opex2;
                        const netIncome1 = operatingIncome1 + otherIncome1 - taxes1;
                        const netIncome2 = operatingIncome2 + otherIncome2 - taxes2;

                        return {
                            grossProfit: { [year1]: grossProfit1, [year2]: grossProfit2 },
                            operatingIncome: { [year1]: operatingIncome1, [year2]: operatingIncome2 },
                            netIncome: { [year1]: netIncome1, [year2]: netIncome2 }
                        };
                    }
                });
            }

            // Generate Cash Flow Statement (Indirect Method - Calculated from Balance Sheet and Income Statement)
            generateCashFlowStatement(options = {}) {
                try {
                    const year1 = YEAR_CONFIG.getYear(0); // First year (e.g., '2024')
                    const year2 = YEAR_CONFIG.getYear(1); // Second year (e.g., '2025')
                    const col1 = YEAR_CONFIG.getAmountColumn(year1); // 'amount_2024'
                    const col2 = YEAR_CONFIG.getAmountColumn(year2); // 'amount_2025'

                    // Get Income Statement to extract Net Income
                    const incomeStatement = this.generateIncomeStatement(options);
                    const incomeDetails = incomeStatement.details.objects();

                    // Get Balance Sheet to calculate changes in working capital
                    const balanceSheet = this.generateBalanceSheet(options);
                    const balanceDetails = balanceSheet.details.objects();

                    // Get Net Income from Income Statement metrics (to ensure consistency)
                    const netIncome1 = incomeStatement.metrics.netIncome[year1];
                    const netIncome2 = incomeStatement.metrics.netIncome[year2];

                    // Calculate changes in Balance Sheet items (working capital changes)
                    const cashFlowData = [];

                    // Operating Activities
                    cashFlowData.push({
                        category: 'Operating Activities',
                        subcategory: 'Net Income',
                        [col1]: netIncome1,
                        [col2]: netIncome2
                    });

                    // Add back non-cash expenses (depreciation, amortization)
                    balanceDetails.forEach(row => {
                        if (CategoryMatcher.isDepreciation(row.name2)) {
                            cashFlowData.push({
                                category: 'Operating Activities',
                                subcategory: row.name2,
                                [col1]: Math.abs(row.variance_amount || 0),
                                [col2]: Math.abs(row.variance_amount || 0)
                            });
                        }
                    });

                    // Changes in working capital (current assets and liabilities)
                    balanceDetails.forEach(row => {
                        if (CategoryMatcher.isCurrentAsset(row.name1)) {
                            const change = (row[col2] || 0) - (row[col1] || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Operating Activities',
                                    subcategory: `Change in ${row.name2}`,
                                    [col1]: 0,
                                    [col2]: -change // Negative because increase in assets uses cash
                                });
                            }
                        }
                    });

                    // Investing Activities (changes in fixed assets)
                    balanceDetails.forEach(row => {
                        if (CategoryMatcher.isFixedAsset(row.name1)) {
                            const change = (row[col2] || 0) - (row[col1] || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Investing Activities',
                                    subcategory: row.name2,
                                    [col1]: 0,
                                    [col2]: -change
                                });
                            }
                        }
                    });

                    // Financing Activities (changes in equity and long-term liabilities)
                    balanceDetails.forEach(row => {
                        if (CategoryMatcher.isLongTermLiability(row.name1)) {
                            const change = (row[col2] || 0) - (row[col1] || 0);
                            if (Math.abs(change) > 0) {
                                cashFlowData.push({
                                    category: 'Financing Activities',
                                    subcategory: row.name2,
                                    [col1]: 0,
                                    [col2]: change
                                });
                            }
                        }
                    });

                    // Convert to Arquero table
                    const cashFlowTable = aq.from(cashFlowData);

                    // Calculate variances
                    const withVariances = this.deriveVarianceColumns(cashFlowTable);

                    // Calculate category totals
                    const categoryTotals = this.calculateCategoryTotals(withVariances);

                    // Calculate net change in cash
                    const totals = categoryTotals.objects();
                    let operating1 = 0, operating2 = 0;
                    let investing1 = 0, investing2 = 0;
                    let financing1 = 0, financing2 = 0;

                    totals.forEach(row => {
                        if (row.name1 === 'Operating Activities') {
                            operating1 = row[col1];
                            operating2 = row[col2];
                        } else if (row.name1 === 'Investing Activities') {
                            investing1 = row[col1];
                            investing2 = row[col2];
                        } else if (row.name1 === 'Financing Activities') {
                            financing1 = row[col1];
                            financing2 = row[col2];
                        }
                    });

                    const netChange1 = operating1 + investing1 + financing1;
                    const netChange2 = operating2 + investing2 + financing2;

                    // Get starting cash from Balance Sheet (cash and cash equivalents)
                    let startingCash1 = 0, startingCash2 = 0;
                    balanceDetails.forEach(row => {
                        if (row.name2) {
                            const subcategoryLower = row.name2.toLowerCase();
                            if (CATEGORY_DEFINITIONS.CASH.some(cat => subcategoryLower.includes(cat))) {
                                startingCash1 += row[col1] || 0;
                                startingCash2 += row[col2] || 0;
                            }
                        }
                    });

                    // Calculate ending cash
                    const endingCash1 = startingCash1 + netChange1;
                    const endingCash2 = startingCash2 + netChange2;

                    return {
                        details: withVariances,
                        totals: categoryTotals,
                        metrics: {
                            netIncome: {
                                [year1]: netIncome1,
                                [year2]: netIncome2
                            },
                            netChange: {
                                [year1]: netChange1,
                                [year2]: netChange2,
                                variance: netChange2 - netChange1
                            },
                            startingCash: {
                                [year1]: startingCash1,
                                [year2]: startingCash2
                            },
                            endingCash: {
                                [year1]: endingCash1,
                                [year2]: endingCash2
                            }
                        }
                    };
                    
                } catch (error) {
                    console.error('Error generating Cash Flow Statement:', error);
                    throw error;
                }
            }

            // Calculate variance between two periods
            calculateVariance(period1, period2) {
                try {
                    const factTable1 = this.dataStore.getFactTable(period1);
                    const factTable2 = this.dataStore.getFactTable(period2);

                    if (!factTable1 || !factTable2) {
                        throw new Error(`Data for periods ${period1} or ${period2} not loaded`);
                    }

                    // Rename amount columns to distinguish periods
                    const table1 = factTable1
                        .select('account_code', 'account_description', 'movement_amount')
                        .rename({ movement_amount: `amount_${period1}` });

                    const table2 = factTable2
                        .select('account_code', 'movement_amount')
                        .rename({ movement_amount: `amount_${period2}` });

                    // Join tables on account_code
                    const joined = table1
                        .join_full(table2, 'account_code')
                        .derive({
                            [`amount_${period1}`]: d => d[`amount_${period1}`] || 0,
                            [`amount_${period2}`]: d => d[`amount_${period2}`] || 0,
                            variance_amount: d => (d[`amount_${period2}`] || 0) - (d[`amount_${period1}`] || 0),
                            variance_percent: d => {
                                const amt1 = d[`amount_${period1}`] || 0;
                                const amt2 = d[`amount_${period2}`] || 0;
                                
                                // Handle division by zero
                                if (amt1 === 0) {
                                    return amt2 === 0 ? 0 : null; // Return null for N/A cases
                                }
                                
                                return ((amt2 - amt1) / Math.abs(amt1)) * 100;
                            }
                        });

                    return joined;

                } catch (error) {
                    console.error('Error calculating variance:', error);
                    throw error;
                }
            }
        }

        // ExportHandler class for Excel export
        class ExportHandler {
            constructor(dataStore) {
                this.dataStore = dataStore;
                // Use global EXPORT_CONFIG constants
            }

            // Helper: Format cells as whole numbers
            formatCellsAsNumbers(row, startCol, endCol) {
                for (let i = startCol; i <= endCol; i++) {
                    if (row.getCell(i).value !== '' && row.getCell(i).value !== null) {
                        row.getCell(i).numFmt = EXPORT_CONFIG.NUMBER_FORMAT;
                    }
                }
            }

            // Helper: Style metric row (bold + highlighted)
            styleMetricRow(row, startCol, endCol, highlighted = true) {
                row.font = { bold: true };
                if (highlighted) {
                    row.fill = { 
                        type: 'pattern', 
                        pattern: 'solid', 
                        fgColor: { argb: EXPORT_CONFIG.COLORS.METRIC_HIGHLIGHT } 
                    };
                }
                this.formatCellsAsNumbers(row, startCol, endCol);
            }

            // Convert Arquero table to array of arrays
            tableToArrays(table, includeHeaders = true) {
                const data = [];
                
                if (includeHeaders) {
                    data.push(table.columnNames());
                }
                
                table.objects().forEach(row => {
                    const rowArray = table.columnNames().map(col => row[col]);
                    data.push(rowArray);
                });
                
                return data;
            }

            // Export all statements to single workbook
            async exportAllStatements(statements) {
                // Show loading indicator
                const exportStatus = document.getElementById('export-status');
                if (exportStatus) {
                    exportStatus.textContent = '‚è≥ Generating Excel file...';
                    exportStatus.style.color = '#007bff';
                }
                
                try {
                    // Validate input
                    if (!statements || Object.keys(statements).length === 0) {
                        throw new Error('No statements available to export');
                    }
                    
                    const workbook = new ExcelJS.Workbook();

                    // Add metadata sheet first
                    const metadataSheet = workbook.addWorksheet('Export Info');
                    
                    // Get current date and time
                    const now = new Date();
                    const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                    const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    
                    // Get username - browsers don't expose system username for security reasons
                    // We'll use a placeholder that users can customize
                    const username = 'System User';
                    
                    // Get input file names from config
                    const inputFiles = [
                        config.inputFiles.trialBalance2024,
                        config.inputFiles.trialBalance2025,
                        config.inputFiles.dates
                    ];
                    
                    // Add metadata rows
                    const metadataRows = [
                        ['Financial Statements Export Information'],
                        [''],
                        ['Export Date:', dateStr],
                        ['Export Time:', timeStr],
                        ['Generated By:', username],
                        [''],
                        ['Input Files:'],
                        ['Trial Balance 2024:', config.inputFiles.trialBalance2024],
                        ['Trial Balance 2025:', config.inputFiles.trialBalance2025],
                        ['Dates Dimension:', config.inputFiles.dates],
                        [''],
                        ['Statements Included:'],
                        ['- Balance Sheet'],
                        ['- Income Statement'],
                        ['- Cash Flow Statement']
                    ];
                    
                    metadataRows.forEach((row, index) => {
                        const excelRow = metadataSheet.addRow(row);
                        
                        // Style the title row
                        if (index === 0) {
                            excelRow.font = { 
                                bold: true, 
                                size: EXPORT_CONFIG.FONT_SIZES.TITLE, 
                                color: { argb: EXPORT_CONFIG.COLORS.HEADER } 
                            };
                        }
                        
                        // Style section headers
                        if (row[0] && (row[0].includes(':') || row[0].includes('Files') || row[0].includes('Included'))) {
                            excelRow.getCell(1).font = { bold: true };
                        }
                    });
                    
                    // Set column widths
                    metadataSheet.getColumn(1).width = EXPORT_CONFIG.COLUMN_WIDTHS.METADATA_LABEL;
                    metadataSheet.getColumn(2).width = EXPORT_CONFIG.COLUMN_WIDTHS.METADATA_VALUE;

                    // Add each statement as a separate worksheet
                    for (const [name, data] of Object.entries(statements)) {
                        const worksheet = workbook.addWorksheet(name);

                        // Determine if this is Cash Flow (2025 only, no variance)
                        const isCashFlow = name === 'Cash Flow Statement';
                        
                        const headers = isCashFlow 
                            ? ['Line Item', '2025']
                            : ['Line Item', '2024', '2025', 'Variance (‚Ç¨)', 'Variance (%)'];
                        
                        // Add header row
                        const headerRow = worksheet.addRow(headers);
                        headerRow.font = { bold: true, color: { argb: EXPORT_CONFIG.COLORS.WHITE } };
                        headerRow.fill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: EXPORT_CONFIG.COLORS.HEADER }
                        };
                        
                        // Center-align all column headers
                        headerRow.eachCell((cell) => {
                            cell.alignment = { horizontal: 'center', vertical: 'middle' };
                        });

                        let rowIndex = 2; // Start after header
                        const categoryStartRows = {}; // Track where each category starts for formulas
                        const categoryEndRows = {}; // Track where each category ends for formulas
                        
                        // Add details
                        const details = data.details.objects();
                        let currentCategory = null;

                        details.forEach(row => {
                            if (row.name1 !== currentCategory) {
                                // Mark end of previous category
                                if (currentCategory) {
                                    categoryEndRows[currentCategory] = rowIndex - 1;
                                }
                                
                                currentCategory = row.name1;
                                categoryStartRows[currentCategory] = rowIndex + 1; // +1 because category header is on current row
                                
                                // Add category header
                                const categoryRow = worksheet.addRow([currentCategory, '', '', '', '']);
                                categoryRow.font = { bold: true };
                                rowIndex++;
                            }
                            
                            // Add detail row
                            const detailRow = isCashFlow
                                ? ['  ' + (row.name2 || row.name1), row.amount_2025]
                                : ['  ' + (row.name2 || row.name1), row.amount_2024, row.amount_2025, row.variance_amount, row.variance_percent];
                            
                            const excelRow = worksheet.addRow(detailRow);
                            
                            // Format numbers as whole numbers
                            this.formatCellsAsNumbers(excelRow, 2, isCashFlow ? 2 : 5);
                            rowIndex++;
                        });
                        
                        // Mark end of last category
                        if (currentCategory) {
                            categoryEndRows[currentCategory] = rowIndex - 1;
                        }

                        // Add empty row
                        worksheet.addRow(['', '', '', '', '']);
                        rowIndex++;

                        // Add calculated metrics if available
                        if (data.metrics) {
                            const metrics = data.metrics;
                            
                            // For Income Statement: Add Gross Profit, Operating Income, Net Income
                            if (name === 'Income Statement') {
                                if (metrics.grossProfit) {
                                    const gpRow = worksheet.addRow(['Gross Profit', metrics.grossProfit['2024'], metrics.grossProfit['2025'], '', '']);
                                    this.styleMetricRow(gpRow, 2, 3);
                                    rowIndex++;
                                }
                                
                                if (metrics.operatingIncome) {
                                    const oiRow = worksheet.addRow(['Operating Income', metrics.operatingIncome['2024'], metrics.operatingIncome['2025'], '', '']);
                                    this.styleMetricRow(oiRow, 2, 3);
                                    rowIndex++;
                                }
                                
                                if (metrics.netIncome) {
                                    const niRow = worksheet.addRow(['Net Income', metrics.netIncome['2024'], metrics.netIncome['2025'], '', '']);
                                    this.styleMetricRow(niRow, 2, 3);
                                    rowIndex++;
                                }
                            }
                            
                            // For Cash Flow: Add Starting Cash, Changes, Ending Cash
                            if (name === 'Cash Flow Statement') {
                                if (metrics.startingCash) {
                                    const scRow = worksheet.addRow(['Starting Cash', metrics.startingCash['2025']]);
                                    this.styleMetricRow(scRow, 2, 2, false);
                                    rowIndex++;
                                }
                                
                                if (metrics.changesInCash) {
                                    const ccRow = worksheet.addRow(['Changes in Cash', metrics.changesInCash['2025']]);
                                    this.styleMetricRow(ccRow, 2, 2, false);
                                    rowIndex++;
                                }
                                
                                if (metrics.endingCash) {
                                    const ecRow = worksheet.addRow(['Ending Cash', metrics.endingCash['2025']]);
                                    this.styleMetricRow(ecRow, 2, 2, true);
                                    rowIndex++;
                                }
                            }
                        }

                        // Add empty row before totals
                        worksheet.addRow(['', '', '', '', '']);
                        rowIndex++;
                        
                        // Add category totals with Excel formulas
                        const totals = data.totals.objects();
                        totals.forEach(row => {
                            const totalLabel = 'Total ' + row.name1;
                            const startRow = categoryStartRows[row.name1];
                            const endRow = categoryEndRows[row.name1];
                            
                            const totalRow = isCashFlow 
                                ? worksheet.addRow([totalLabel, null])
                                : worksheet.addRow([totalLabel, null, null, null, null]);
                            
                            totalRow.font = { bold: true };
                            
                            // Add formulas or static values
                            if (startRow && endRow && startRow <= endRow) {
                                totalRow.getCell(2).value = { formula: `SUM(B${startRow}:B${endRow})` };
                                
                                if (!isCashFlow) {
                                    totalRow.getCell(3).value = { formula: `SUM(C${startRow}:C${endRow})` };
                                    totalRow.getCell(4).value = { formula: `C${rowIndex}-B${rowIndex}` };
                                    totalRow.getCell(5).value = { formula: `IF(B${rowIndex}=0,0,(D${rowIndex}/ABS(B${rowIndex}))*100)` };
                                }
                            } else {
                                // Fallback to static values
                                totalRow.getCell(2).value = isCashFlow ? row.amount_2025 : row.amount_2024;
                                if (!isCashFlow) {
                                    totalRow.getCell(3).value = row.amount_2025;
                                    totalRow.getCell(4).value = row.variance_amount;
                                    totalRow.getCell(5).value = row.variance_percent;
                                }
                            }
                            
                            // Format as whole numbers
                            this.formatCellsAsNumbers(totalRow, 2, isCashFlow ? 2 : 5);
                            rowIndex++;
                        });

                        // Set column widths
                        worksheet.getColumn(1).width = EXPORT_CONFIG.COLUMN_WIDTHS.LINE_ITEM;
                        worksheet.getColumn(2).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                        if (!isCashFlow) {
                            worksheet.getColumn(3).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                            worksheet.getColumn(4).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                            worksheet.getColumn(5).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                        }
                    }

                    // Generate buffer and download
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = config.outputFiles.allStatements;
                    link.click();
                    window.URL.revokeObjectURL(url);

                    console.log('Exported all statements successfully');
                    
                    // Show success message
                    if (exportStatus) {
                        exportStatus.textContent = '‚úÖ Export completed successfully';
                        exportStatus.style.color = '#28a745';
                        
                        // Clear message after 3 seconds
                        setTimeout(() => {
                            exportStatus.textContent = '';
                        }, 3000);
                    }

                } catch (error) {
                    console.error('Error exporting all statements:', error);
                    
                    // Show user-friendly error message
                    if (exportStatus) {
                        let errorMessage = '‚ùå Export failed: ';
                        
                        if (error.message.includes('No statements')) {
                            errorMessage += 'No statements available. Please load data first.';
                        } else if (error.message.includes('writeBuffer')) {
                            errorMessage += 'Failed to generate Excel file. Please try again.';
                        } else if (error.message.includes('Blob')) {
                            errorMessage += 'Browser does not support file download.';
                        } else {
                            errorMessage += error.message || 'Unknown error occurred.';
                        }
                        
                        exportStatus.textContent = errorMessage;
                        exportStatus.style.color = '#dc3545';
                        
                        // Keep error message visible longer
                        setTimeout(() => {
                            exportStatus.textContent = '';
                        }, 5000);
                    }
                    
                    // Re-throw for debugging purposes
                    throw error;
                }
            }
        }

        // InteractiveUI class for rendering financial statements
        class InteractiveUI {
            constructor() {
                this.currentStatement = null;
                this.sortColumn = null;
                this.sortDirection = 'asc';
            }

            // Helper: Render period dropdown with optgroups
            renderPeriodDropdown(id, currentValue, years = APP_CONFIG.YEARS) {
                let html = '<th class="col-number">';
                html += `<select id="${id}" class="period-dropdown-header">`;

                years.forEach(year => {
                    html += `<optgroup label="${year}">`;
                    html += `<option value="${year}-all" ${currentValue === `${year}-all` ? 'selected' : ''}>${year} (All)</option>`;

                    // Add quarter options
                    for (let q = 1; q <= 4; q++) {
                        const value = `${year}-Q${q}`;
                        html += `<option value="${value}" ${currentValue === value ? 'selected' : ''}>${year} (Q${q})</option>`;
                    }

                    // Add individual period options
                    for (let i = 1; i <= APP_CONFIG.PERIODS_PER_YEAR; i++) {
                        const value = `${year}-${i}`;
                        html += `<option value="${value}" ${currentValue === value ? 'selected' : ''}>${year} (P${i})</option>`;
                    }
                    html += '</optgroup>';
                });

                html += '</select>';
                html += '</th>';
                return html;
            }

            // Helper: Render a table row with consistent structure
            renderTableRow(type, label, amount2024, amount2025, varianceAmount, variancePercent, show2024, show2025, variance1Mode, variance2Mode, options = {}) {
                const { colspan = 2, cssClass = 'number', bold = false, indent = false } = options;
                const labelText = bold ? `<strong>${label}</strong>` : label;
                const indentClass = indent ? ' class="indent"' : '';
                
                return `
                    <tr class="${type}-row">
                        <td colspan="${colspan}"${indentClass}>${labelText}</td>
                        ${this.renderDataCells(amount2024, amount2025, varianceAmount, variancePercent, show2024, show2025, variance1Mode, variance2Mode, cssClass)}
                    </tr>
                `;
            }

            // Format number with thousand separators (whole numbers, no decimals)
            formatNumber(value) {
                if (value === null || value === undefined) return 'N/A';
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(Math.round(value));
            }

            // Helper function to render data cells based on year toggles and variance column settings
            renderDataCells(amount2024, amount2025, varianceAmount, variancePercent, show2024, show2025, variance1Mode, variance2Mode, cssClass = 'number') {
                let html = '';
                if (show2024) {
                    html += `<td class="${cssClass}">${this.formatNumber(amount2024)}</td>`;
                }
                if (show2025) {
                    html += `<td class="${cssClass}">${this.formatNumber(amount2025)}</td>`;
                }
                
                // Variance Column 1
                if (variance1Mode === 'amount') {
                    html += `<td class="${cssClass} ${varianceAmount >= 0 ? 'positive' : 'negative'}">${this.formatNumber(varianceAmount)}</td>`;
                } else if (variance1Mode === 'percent') {
                    html += `<td class="${cssClass} ${variancePercent >= 0 ? 'positive' : 'negative'}">${this.formatNumber(variancePercent)}%</td>`;
                }
                // If variance1Mode === 'none', don't add a column
                
                // Variance Column 2
                if (variance2Mode === 'amount') {
                    html += `<td class="${cssClass} ${varianceAmount >= 0 ? 'positive' : 'negative'}">${this.formatNumber(varianceAmount)}</td>`;
                } else if (variance2Mode === 'percent') {
                    html += `<td class="${cssClass} ${variancePercent >= 0 ? 'positive' : 'negative'}">${this.formatNumber(variancePercent)}%</td>`;
                }
                // If variance2Mode === 'none', don't add a column
                
                return html;
            }

            // Render statement table
            renderStatement(statementData, statementType, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                this.currentStatement = statementData;
                this.currentStatementType = statementType;

                // Get years from config
                const year1 = YEAR_CONFIG.getYear(0); // First year (e.g., '2024')
                const year2 = YEAR_CONFIG.getYear(1); // Second year (e.g., '2025')
                const col1 = YEAR_CONFIG.getAmountColumn(year1); // 'amount_2024'
                const col2 = YEAR_CONFIG.getAmountColumn(year2); // 'amount_2025'

                // Create table HTML
                let html = '<table class="financial-table">';

                // Check which years and variance should be shown
                // For Cash Flow Statement, only show year2 (no year1 column)
                // Try header checkboxes first, fall back to true if not found (initial render)
                const headerYear1Checkbox = document.getElementById(`show-${year1}-header`);
                const headerYear2Checkbox = document.getElementById(`show-${year2}-header`);
                let showYear1 = headerYear1Checkbox ? headerYear1Checkbox.checked : true;
                let showYear2 = headerYear2Checkbox ? headerYear2Checkbox.checked : true;

                // Override for Cash Flow: only show year2
                if (statementType === UI_STATEMENT_TYPES.CASH_FLOW) {
                    showYear1 = false;
                    showYear2 = true;
                }

                // Get variance column settings
                const variance1Dropdown = document.getElementById('variance-1-header');
                const variance2Dropdown = document.getElementById('variance-2-header');
                const variance1Mode = variance1Dropdown ? variance1Dropdown.value : 'none';
                const variance2Mode = variance2Dropdown ? variance2Dropdown.value : 'none';

                // Calculate column span dynamically
                let colCount = 2; // Detail Level dropdown + Line Item column
                if (showYear1) colCount++;
                if (showYear2) colCount++;
                if (variance1Mode !== 'none') colCount++;
                if (variance2Mode !== 'none') colCount++;
                const colSpan = colCount;

                // Get current period selections before regenerating (to preserve them)
                const currentPeriodYear1 = document.getElementById(`period-${year1}-header`)?.value || `${year1}-all`;
                const currentPeriodYear2 = document.getElementById(`period-${year2}-header`)?.value || `${year2}-all`;

                // Get current detail level selection
                const detailLevelDropdown = document.getElementById('detail-level-header');
                const detailLevel = detailLevelDropdown ? detailLevelDropdown.value : 'name1';

                // Table header
                html += '<thead><tr>';
                // Detail Level dropdown (no Line Item label needed)
                html += '<th class="col-label" colspan="2">';
                html += '<select id="detail-level-header" class="variance-dropdown detail-level-dropdown">';
                html += `<option value="name1" ${detailLevel === 'name1' ? 'selected' : ''}>Category</option>`;
                html += `<option value="name2" ${detailLevel === 'name2' ? 'selected' : ''}>Subcategory</option>`;
                html += '</select>';
                html += '</th>';
                // Period dropdowns using helper function
                if (showYear1) {
                    html += this.renderPeriodDropdown(`period-${year1}-header`, currentPeriodYear1);
                }
                if (showYear2) {
                    html += this.renderPeriodDropdown(`period-${year2}-header`, currentPeriodYear2);
                }
                // Variance Column 1
                html += '<th class="col-number">';
                html += '<select id="variance-1-header" class="variance-dropdown">';
                html += `<option value="none" ${variance1Mode === 'none' ? 'selected' : ''}>-</option>`;
                html += `<option value="amount" ${variance1Mode === 'amount' ? 'selected' : ''}>Variance (‚Ç¨)</option>`;
                html += `<option value="percent" ${variance1Mode === 'percent' ? 'selected' : ''}>Variance (%)</option>`;
                html += '</select>';
                html += '</th>';
                
                // Variance Column 2
                html += '<th class="col-number">';
                html += '<select id="variance-2-header" class="variance-dropdown">';
                html += `<option value="none" ${variance2Mode === 'none' ? 'selected' : ''}>-</option>`;
                html += `<option value="amount" ${variance2Mode === 'amount' ? 'selected' : ''}>Variance (‚Ç¨)</option>`;
                html += `<option value="percent" ${variance2Mode === 'percent' ? 'selected' : ''}>Variance (%)</option>`;
                html += '</select>';
                html += '</th>';
                html += '</tr></thead>';
                
                html += '<tbody>';

                // Render details grouped by category
                const details = statementData.details.objects();
                const totals = statementData.totals.objects();
                
                // Pre-calculate Total Assets for Balance Sheet (to insert in the middle)
                // Total Assets = Fixed Assets + Current Assets
                // Fixed Assets = Immateri√´le vaste activa + Materi√´le vaste activa
                // Current Assets = Voorraden + Vorderingen + Liquide Middelen
                let totalAssetsYear1 = 0, totalAssetsYear2 = 0;
                let totalAssetsInserted = false;
                if (statementType === UI_STATEMENT_TYPES.BALANCE_SHEET) {
                    totals.forEach(row => {
                        const categoryLower = row.name1.toLowerCase();
                        if (CATEGORY_DEFINITIONS.ASSETS.some(cat => categoryLower.includes(cat))) {
                            totalAssetsYear1 += row[col1] || 0;
                            totalAssetsYear2 += row[col2] || 0;
                        }
                    });
                }
                
                // Flag to ensure Operating Income is only inserted once
                let operatingIncomeInserted = false;
                
                let currentCategory = null;
                
                details.forEach(row => {
                    // Insert Total Assets before first Passiva/Eigen vermogen category for Balance Sheet
                    if (statementType === UI_STATEMENT_TYPES.BALANCE_SHEET &&
                        !totalAssetsInserted &&
                        row.name1 !== currentCategory) {
                        if (CategoryMatcher.isLiabilityOrEquity(row.name1)) {

                            totalAssetsInserted = true;
                            const { amount: assetsVariance, percent: assetsVariancePercent } =
                                VarianceCalculator.calculate(totalAssetsYear2, totalAssetsYear1);

                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                            html += this.renderTableRow('total', 'TOTAL ASSETS', totalAssetsYear1, totalAssetsYear2, assetsVariance, assetsVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                        }
                    }

                    // Add category header if changed
                    if (row.name1 !== currentCategory) {
                        currentCategory = row.name1;
                        html += `<tr class="category-header"><td colspan="${colSpan}"><strong>${currentCategory}</strong></td></tr>`;
                    }

                    // Add detail row - always show if subcategory exists
                    const shouldShowDetail = row.name2;

                    if (shouldShowDetail) {
                        html += this.renderTableRow('detail', row.name2, row[col1], row[col2], row.variance_amount, row.variance_percent, showYear1, showYear2, variance1Mode, variance2Mode, { indent: true });

                        // Insert Gross Profit inline after "Kostprijs van de omzet" for Income Statement
                        if (statementType === UI_STATEMENT_TYPES.INCOME_STATEMENT &&
                            statementData.metrics &&
                            row.name2.toLowerCase().includes('kostprijs')) {

                            const metrics = statementData.metrics;
                            const { amount: gpVariance, percent: gpVariancePercent } =
                                VarianceCalculator.calculateForMetric(metrics.grossProfit, year2, year1);

                            html += this.renderTableRow('metric', 'Brutowinst (Gross Profit)', metrics.grossProfit[year1], metrics.grossProfit[year2], gpVariance, gpVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });

                            // Empty line after Gross Profit
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                        }

                        // Insert Operating Income inline after "Overige Personeelskosten" for Income Statement (only once)
                        if (statementType === UI_STATEMENT_TYPES.INCOME_STATEMENT &&
                            statementData.metrics &&
                            !operatingIncomeInserted &&
                            row.name2 && row.name2.toLowerCase().includes('overige personeelskosten')) {

                            operatingIncomeInserted = true;

                            const metrics = statementData.metrics;
                            const { amount: oiVariance, percent: oiVariancePercent } =
                                VarianceCalculator.calculateForMetric(metrics.operatingIncome, year2, year1);

                            html += this.renderTableRow('metric', 'Operating Income', metrics.operatingIncome[year1], metrics.operatingIncome[year2], oiVariance, oiVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });

                            // Empty line after Operating Income
                            html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                        }
                    }
                });

                // Check if category totals should be shown (based on detail level)
                const showCategoryTotals = detailLevel === 'name1';

                // Calculate grand totals for Balance Sheet (Liabilities & Equity only, Assets already shown)
                let totalLiabilitiesEquityYear1 = 0, totalLiabilitiesEquityYear2 = 0;

                // Add category totals (optional)
                if (showCategoryTotals) {
                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    html += `<tr class="section-header"><td colspan="${colSpan}"><strong>Category Totals</strong></td></tr>`;
                }

                totals.forEach(row => {
                    if (showCategoryTotals) {
                        html += this.renderTableRow('subtotal', `Total ${row.name1}`, row[col1], row[col2], row.variance_amount, row.variance_percent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });
                    }

                    // Accumulate for Balance Sheet Liabilities & Equity total
                    if (statementType === UI_STATEMENT_TYPES.BALANCE_SHEET) {
                        if (CategoryMatcher.isLiabilityOrEquity(row.name1)) {
                            totalLiabilitiesEquityYear1 += row[col1] || 0;
                            totalLiabilitiesEquityYear2 += row[col2] || 0;
                        }
                    }
                });

                // Add Balance Sheet Liabilities & Equity total at the end
                if (statementType === UI_STATEMENT_TYPES.BALANCE_SHEET && (totalLiabilitiesEquityYear1 !== 0 || totalLiabilitiesEquityYear2 !== 0)) {
                    const { amount: leVariance, percent: leVariancePercent } =
                        VarianceCalculator.calculate(totalLiabilitiesEquityYear2, totalLiabilitiesEquityYear1);

                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;

                    // Total Liabilities & Equity
                    html += this.renderTableRow('total', 'TOTAL LIABILITIES & EQUITY', totalLiabilitiesEquityYear1, totalLiabilitiesEquityYear2, leVariance, leVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });
                }

                // Add Net Income at the bottom for Income Statement (after all categories, similar to bottom line)
                if (statementType === UI_STATEMENT_TYPES.INCOME_STATEMENT && statementData.metrics) {
                    const metrics = statementData.metrics;
                    const { amount: niVariance, percent: niVariancePercent } =
                        VarianceCalculator.calculateForMetric(metrics.netIncome, year2, year1);

                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    html += this.renderTableRow('total', 'Net Income', metrics.netIncome[year1], metrics.netIncome[year2], niVariance, niVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });
                }

                // Add cash reconciliation for Cash Flow Statement
                if (statementType === UI_STATEMENT_TYPES.CASH_FLOW && statementData.metrics) {
                    const metrics = statementData.metrics;

                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    html += `<tr class="section-header"><td colspan="${colSpan}"><strong>Cash Reconciliation</strong></td></tr>`;

                    // Starting Cash
                    if (metrics.startingCash) {
                        const { amount: scVariance, percent: scVariancePercent } =
                            VarianceCalculator.calculateForMetric(metrics.startingCash, year2, year1);

                        html += this.renderTableRow('detail', 'Starting Cash', metrics.startingCash[year1], metrics.startingCash[year2], scVariance, scVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode);
                    }

                    // Net Change in Cash
                    if (metrics.netChange) {
                        const ncVariance = metrics.netChange.variance;
                        const ncVariancePercent = metrics.netChange[year1] !== 0 ?
                            (ncVariance / Math.abs(metrics.netChange[year1])) * 100 : 0;

                        html += this.renderTableRow('detail', 'Changes in Cash', metrics.netChange[year1], metrics.netChange[year2], ncVariance, ncVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode);
                    }

                    // Ending Cash
                    if (metrics.endingCash) {
                        const { amount: ecVariance, percent: ecVariancePercent } =
                            VarianceCalculator.calculateForMetric(metrics.endingCash, year2, year1);

                        html += this.renderTableRow('total', 'Ending Cash', metrics.endingCash[year1], metrics.endingCash[year2], ecVariance, ecVariancePercent, showYear1, showYear2, variance1Mode, variance2Mode, { bold: true });
                    }
                }

                // Add balance check for Balance Sheet
                if (statementType === UI_STATEMENT_TYPES.BALANCE_SHEET && statementData.balanced !== undefined) {
                    html += `<tr class="spacer-row"><td colspan="${colSpan}"></td></tr>`;
                    if (statementData.balanced) {
                        html += `<tr class="info-row"><td colspan="${colSpan}" class="success-message">‚úÖ Balance Sheet is balanced</td></tr>`;
                    } else {
                        html += `<tr class="info-row"><td colspan="${colSpan}" class="warning-message">‚ö†Ô∏è Balance Sheet imbalance: ${this.formatNumber(statementData.imbalance)}</td></tr>`;
                    }
                }

                html += '</tbody></table>';
                
                container.innerHTML = html;

                // Add event listeners for header period dropdowns
                const periodYear1HeaderDropdown = container.querySelector(`#period-${year1}-header`);
                const periodYear2HeaderDropdown = container.querySelector(`#period-${year2}-header`);

                if (periodYear1HeaderDropdown) {
                    periodYear1HeaderDropdown.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-generate and render the current statement with new period filter
                        if (this.currentStatementType) {
                            // Trigger regeneration through the UI controller
                            window.uiController.generateAndDisplayStatement(this.currentStatementType);
                        }
                    });
                }

                if (periodYear2HeaderDropdown) {
                    periodYear2HeaderDropdown.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-generate and render the current statement with new period filter
                        if (this.currentStatementType) {
                            // Trigger regeneration through the UI controller
                            window.uiController.generateAndDisplayStatement(this.currentStatementType);
                        }
                    });
                }
                
                // Add event listeners for variance column dropdowns
                const variance1HeaderDropdown = container.querySelector('#variance-1-header');
                const variance2HeaderDropdown = container.querySelector('#variance-2-header');
                
                if (variance1HeaderDropdown) {
                    variance1HeaderDropdown.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-render the current statement with new variance column setting
                        if (this.currentStatementType) {
                            window.uiController.generateAndDisplayStatement(this.currentStatementType);
                        }
                    });
                }
                
                if (variance2HeaderDropdown) {
                    variance2HeaderDropdown.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-render the current statement with new variance column setting
                        if (this.currentStatementType) {
                            window.uiController.generateAndDisplayStatement(this.currentStatementType);
                        }
                    });
                }
                
                // Add event listener for detail level dropdown
                const detailLevelHeaderDropdown = container.querySelector('#detail-level-header');
                
                if (detailLevelHeaderDropdown) {
                    detailLevelHeaderDropdown.addEventListener('change', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        // Re-render the current statement with new detail level setting
                        if (this.currentStatementType) {
                            window.uiController.generateAndDisplayStatement(this.currentStatementType);
                        }
                    });
                }
                
                // Enable tooltips
                this.enableTooltips(container);
            }

            // Sorting functionality removed - not needed

            // Enable drill-down on subtotal rows (placeholder for future implementation)
            enableDrillDown(container) {
                // This would expand/collapse detail rows under subtotals
                // Implementation depends on data structure with hierarchical relationships
                console.log('Drill-down feature: To be implemented with hierarchical data');
            }

            // Enable filtering (placeholder for future implementation)
            enableFiltering(container) {
                // This would add filter controls and apply filters to the data
                console.log('Filtering feature: To be implemented');
            }

            // Enable tooltips on amount cells
            enableTooltips(container) {
                const numberCells = container.querySelectorAll('td.number');
                
                numberCells.forEach(cell => {
                    cell.addEventListener('mouseenter', (e) => {
                        this.showTooltip(e.target, {
                            value: cell.textContent,
                            info: 'Hover for details'
                        });
                    });
                    
                    cell.addEventListener('mouseleave', () => {
                        this.hideTooltip();
                    });
                });
            }

            // Show tooltip
            showTooltip(element, data) {
                // Remove existing tooltip
                this.hideTooltip();
                
                // Create tooltip element
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.id = 'financial-tooltip';
                
                // Tooltip content
                tooltip.innerHTML = `
                    <div class="tooltip-content">
                        <strong>Value:</strong> ${data.value}<br>
                        <em>${data.info}</em>
                    </div>
                `;
                
                document.body.appendChild(tooltip);
                
                // Position tooltip near cursor
                const rect = element.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';
            }

            // Hide tooltip
            hideTooltip() {
                const tooltip = document.getElementById('financial-tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.dataStore = new DataStore();
                this.dataLoader = new DataLoader();
                this.statementGenerator = new StatementGenerator(this.dataStore);
                this.interactiveUI = new InteractiveUI();
                this.exportHandler = new ExportHandler(this.dataStore);
                this.currentStatementType = UI_STATEMENT_TYPES.BALANCE_SHEET;
                this.currentStatementData = null;
            }

            // Update file status indicator
            updateFileStatus(fileId, status, message) {
                const statusElement = document.getElementById(`status-${fileId}`);
                if (statusElement) {
                    if (status === 'success') {
                        statusElement.textContent = message ? `‚úÖ ${message}` : '‚úÖ';
                        statusElement.style.color = '#28a745';
                    } else if (status === 'error') {
                        statusElement.textContent = '‚ùå';
                        statusElement.style.color = '#dc3545';
                    } else if (status === 'loading') {
                        statusElement.textContent = '‚è≥';
                        statusElement.style.color = '#ffc107';
                    }
                }
            }

            // Unified status message display
            showStatusMessage(message, type = 'info') {
                const loadingStatus = document.getElementById('loading-status');
                if (!loadingStatus) return;
                
                const statusConfig = {
                    info: { 
                        icon: UI_CONFIG.STATUS_ICONS.INFO, 
                        color: UI_CONFIG.STATUS_COLORS.INFO 
                    },
                    error: { 
                        icon: UI_CONFIG.STATUS_ICONS.ERROR, 
                        color: UI_CONFIG.STATUS_COLORS.ERROR 
                    },
                    success: { 
                        icon: UI_CONFIG.STATUS_ICONS.SUCCESS, 
                        color: UI_CONFIG.STATUS_COLORS.SUCCESS 
                    }
                };
                
                const { icon, color } = statusConfig[type] || statusConfig.info;
                loadingStatus.textContent = icon + message;
                loadingStatus.style.color = color;
            }

            // Convenience methods
            showLoadingMessage(message) {
                this.showStatusMessage(message, 'info');
            }

            showErrorMessage(message) {
                this.showStatusMessage(message, 'error');
            }

            showSuccessMessage(message) {
                this.showStatusMessage(message, 'success');
            }

            // Handle input directory selection
            async handleSelectInputDirectory() {
                try {
                    await this.dataLoader.selectInputDirectory();
                    const statusText = document.getElementById('input-dir-status');
                    const dirHandle = this.dataLoader.inputDirHandle;
                    const dirName = dirHandle.name;

                    // Try to get full path (if available in browser)
                    let pathDisplay = dirName;
                    try {
                        if (dirHandle.resolve) {
                            const path = await dirHandle.resolve(dirHandle);
                            if (path && path.length > 0) {
                                pathDisplay = path.join('/');
                            }
                        }
                    } catch (e) {
                        // Path not available, use directory name only
                    }

                    statusText.textContent = `üìÅ ${pathDisplay}`;
                    statusText.style.color = '#28a745';
                    
                    // Check if directory is named "input"
                    if (dirName.toLowerCase() !== 'input') {
                        const errorMsg = `Directory must be named "input" (current: "${dirName}")`;
                        this.showErrorMessage(errorMsg);
                        console.error(errorMsg);
                        return;
                    }
                    
                    console.log('Directory named "input" detected, checking for files...');
                    
                    // Check if required files exist
                    const filesExist = await this.checkRequiredFilesExist();
                    
                    if (!filesExist) {
                        const errorMsg = 'Required files not found in directory. Please ensure the directory contains the trial balance files.';
                        this.showErrorMessage(errorMsg);
                        console.error(errorMsg);
                        return;
                    }
                    
                    console.log('Required files found, loading...');
                    // Automatically load files
                    await this.handleLoadAllFiles();
                    
                } catch (error) {
                    this.showErrorMessage(error.message);
                }
            }
            
            // Check if required files exist in the selected directory
            async checkRequiredFilesExist() {
                try {
                    const requiredFiles = [
                        config.inputFiles.trialBalance2024,
                        config.inputFiles.trialBalance2025
                    ];
                    
                    for (const filename of requiredFiles) {
                        try {
                            await this.dataLoader.inputDirHandle.getFileHandle(filename);
                        } catch (error) {
                            console.log(`File not found: ${filename}`);
                            return false;
                        }
                    }
                    
                    return true;
                } catch (error) {
                    console.error('Error checking files:', error);
                    return false;
                }
            }

            // Load all files
            async handleLoadAllFiles() {
                this.showLoadingMessage('Loading trial balance files...');
                
                try {
                    // Step 1: Load trial balance for 2024 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2024 trial balance...');
                    this.updateFileStatus('tb2024', 'loading');
                    const { movements: movements2024, balances: balances2024 } = await this.dataLoader.loadTrialBalance('2024');
                    
                    this.dataStore.setFactTable(movements2024, '2024', 'movements');
                    this.dataStore.setFactTable(balances2024, '2024', 'balances');
                    this.updateFileStatus('tb2024', 'success', `M:${movements2024.numRows()} B:${balances2024.numRows()}`);

                    // Step 2: Load trial balance for 2025 (movements and balances with hierarchy included)
                    this.showLoadingMessage('Loading 2025 trial balance...');
                    this.updateFileStatus('tb2025', 'loading');
                    const { movements: movements2025, balances: balances2025 } = await this.dataLoader.loadTrialBalance('2025');
                    
                    this.dataStore.setFactTable(movements2025, '2025', 'movements');
                    this.dataStore.setFactTable(balances2025, '2025', 'balances');
                    this.updateFileStatus('tb2025', 'success', `M:${movements2025.numRows()} B:${balances2025.numRows()}`);
                    
                    // Step 3: Create combined movements table for both years
                    this.showLoadingMessage('Combining data...');
                    const combinedMovements = movements2024.concat(movements2025);
                    this.dataStore.setCombinedMovements(combinedMovements);
                    console.log(`Combined movements table created: ${combinedMovements.numRows()} rows`);
                    
                    // Update combined TB count
                    const combinedCount = movements2024.numRows() + balances2024.numRows() + movements2025.numRows() + balances2025.numRows();
                    this.updateFileStatus('tb2425', 'success', `(${combinedCount} total)`);

                    // Get loaded years from DataStore
                    const loadedYears = this.dataStore.getAllPeriods();
                    console.log(`Loaded trial balance years: ${loadedYears.join(', ')}`);
                    
                    // Validate data and show results
                    this.validateAndDisplayResults();
                    
                    // Clear loading message and log success to console
                    const loadingStatus = document.getElementById('loading-status');
                    if (loadingStatus) {
                        loadingStatus.textContent = '';
                    }
                    console.log('‚úÖ All files loaded successfully!');

                    // Update status to show file names
                    const statusText = document.getElementById('input-dir-status');
                    if (statusText) {
                        const dirHandle = this.dataLoader.inputDirHandle;
                        const dirName = dirHandle.name;

                        // Try to get full path
                        let pathDisplay = dirName;
                        try {
                            if (dirHandle.resolve) {
                                const path = await dirHandle.resolve(dirHandle);
                                if (path && path.length > 0) {
                                    pathDisplay = path.join('/');
                                }
                            }
                        } catch (e) {
                            // Path not available
                        }

                        const file1 = config.inputFiles.trialBalance2024;
                        const file2 = config.inputFiles.trialBalance2025;
                        statusText.innerHTML = `
                            <div style="line-height: 1.5;">
                                <div style="margin-bottom: 4px;"><strong>üìÅ Directory:</strong> ${pathDisplay}</div>
                                <div style="font-size: 0.9em; color: #666;">
                                    <div>‚Ä¢ ${file1}</div>
                                    <div>‚Ä¢ ${file2}</div>
                                </div>
                            </div>
                        `;
                        statusText.style.color = '#28a745';
                    }
                    
                    // Show statement section
                    document.getElementById('statement-section').style.display = 'block';
                    
                    // Enable export button
                    document.getElementById('export-all').disabled = false;
                    
                    // Generate and display default statement (Balance Sheet)
                    this.generateAndDisplayStatement(UI_STATEMENT_TYPES.BALANCE_SHEET);

                } catch (error) {
                    console.error('File loading error:', error);
                    console.error('Error stack:', error.stack);
                    
                    // Provide user-friendly error messages based on error type
                    let userMessage = 'Failed to load files: ';
                    
                    if (error.message.includes('File not found')) {
                        userMessage += 'One or more required files are missing from the selected directory. Please ensure the directory contains the trial balance files.';
                    } else if (error.message.includes('Input directory not selected')) {
                        userMessage += 'Please select an input directory first.';
                    } else if (error.message.includes('File is empty')) {
                        userMessage += 'One of the files is empty or invalid. Please check the file format.';
                    } else if (error.message.includes('missing required columns')) {
                        userMessage += 'File structure is invalid. ' + error.message;
                    } else if (error.message.includes('permission')) {
                        userMessage += 'Permission denied. Please ensure you have access to the selected directory.';
                    } else if (error.message.includes('ExcelJS')) {
                        userMessage += 'Failed to parse Excel file. Please ensure the files are valid Excel workbooks.';
                    } else {
                        userMessage += error.message || 'Unknown error occurred.';
                    }
                    
                    this.showErrorMessage(userMessage);
                    
                    // Update status indicators to show error
                    this.updateFileStatus('tb2024', 'error');
                    this.updateFileStatus('tb2025', 'error');
                    
                    // Show validation container with error
                    const validationContainer = document.getElementById('validation-messages');
                    const errorsContainer = document.getElementById('validation-errors');
                    
                    if (validationContainer && errorsContainer) {
                        errorsContainer.innerHTML = '';
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'validation-error-item';
                        errorDiv.innerHTML = `<strong>Loading Error:</strong> ${userMessage}`;
                        errorsContainer.appendChild(errorDiv);
                        validationContainer.style.display = 'block';
                    }
                }
            }

            // Validate data and display results
            validateAndDisplayResults() {
                const validation = this.statementGenerator.validateData();
                const validationContainer = document.getElementById('validation-messages');
                const errorsContainer = document.getElementById('validation-errors');
                const warningsContainer = document.getElementById('validation-warnings');

                // Clear previous messages
                errorsContainer.innerHTML = '';
                warningsContainer.innerHTML = '';

                // Display Afrondingsverschil replacements
                if (window.afrondingsReplacements && window.afrondingsReplacements.length > 0) {
                    window.afrondingsReplacements.forEach(replacement => {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'validation-warning-item';
                        infoDiv.innerHTML = `‚ÑπÔ∏è <strong>Account replaced:</strong> ${replacement}`;
                        warningsContainer.appendChild(infoDiv);
                    });
                }

                // Display errors
                if (validation.errors.length > 0) {
                    validation.errors.forEach(error => {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'validation-error-item';
                        errorDiv.textContent = '‚ùå ' + error;
                        errorsContainer.appendChild(errorDiv);
                    });
                }

                // Display warnings
                if (validation.warnings.length > 0) {
                    validation.warnings.forEach(warning => {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'validation-warning-item';
                        warningDiv.textContent = '‚ö†Ô∏è ' + warning;
                        warningsContainer.appendChild(warningDiv);
                    });
                }

                // Display unmapped accounts if any
                if (validation.unmappedAccounts.length > 0) {
                    const unmappedDiv = document.createElement('div');
                    unmappedDiv.className = 'validation-warning-item';
                    unmappedDiv.innerHTML = `
                        <strong>Unmapped Accounts (${validation.unmappedAccounts.length}):</strong>
                        <div class="unmapped-accounts-list">
                            ${validation.unmappedAccounts.join(', ')}
                        </div>
                    `;
                    warningsContainer.appendChild(unmappedDiv);
                }

                // Show validation container if there are any messages
                if (validation.errors.length > 0 || validation.warnings.length > 0) {
                    validationContainer.style.display = 'block';
                } else {
                    validationContainer.style.display = 'none';
                }
            }

            // Generate and display statement
            generateAndDisplayStatement(statementType) {
                try {
                    // Validate that data is loaded
                    if (!this.dataStore.getCombinedMovements()) {
                        throw new Error('No data loaded. Please load trial balance files first.');
                    }

                    // Get years from config
                    const year1 = YEAR_CONFIG.getYear(0);
                    const year2 = YEAR_CONFIG.getYear(1);

                    // Get period selections from header dropdowns (fallback to defaults if not found)
                    const periodYear1 = document.getElementById(`period-${year1}-header`)?.value || `${year1}-all`;
                    const periodYear2 = document.getElementById(`period-${year2}-header`)?.value || `${year2}-all`;
                    const periodOptions = {
                        [`period${year1}`]: periodYear1,
                        [`period${year2}`]: periodYear2
                    };
                    
                    let statementData;
                    let statementName;
                    
                    switch(statementType) {
                        case UI_STATEMENT_TYPES.BALANCE_SHEET:
                            statementName = 'Balance Sheet';
                            statementData = this.statementGenerator.generateBalanceSheet(periodOptions);
                            break;
                        case UI_STATEMENT_TYPES.INCOME_STATEMENT:
                            statementName = 'Income Statement';
                            statementData = this.statementGenerator.generateIncomeStatement(periodOptions);
                            break;
                        case UI_STATEMENT_TYPES.CASH_FLOW:
                            statementName = 'Cash Flow Statement';
                            statementData = this.statementGenerator.generateCashFlowStatement(periodOptions);
                            break;
                        default:
                            throw new Error('Unknown statement type: ' + statementType);
                    }
                    
                    // Validate statement data
                    if (!statementData || !statementData.details) {
                        throw new Error('Statement generation returned invalid data');
                    }
                    
                    this.interactiveUI.renderStatement(statementData, statementType, 'statement-display');
                    this.currentStatementType = statementType;
                    this.currentStatementData = statementData;
                    
                    console.log(`${statementName} generated successfully with ${statementData.details.numRows()} detail rows`);
                    
                } catch (error) {
                    console.error('Error generating statement:', error);
                    console.error('Error stack:', error.stack);
                    
                    const display = document.getElementById('statement-display');
                    if (display) {
                        let errorMessage = 'Failed to generate statement: ';
                        
                        if (error.message.includes('No data loaded')) {
                            errorMessage += 'Please load trial balance files first using the "Load Files" button.';
                        } else if (error.message.includes('Required data not loaded')) {
                            errorMessage += 'Trial balance data is incomplete. Please reload the files.';
                        } else if (error.message.includes('Unknown statement type')) {
                            errorMessage += 'Invalid statement type selected.';
                        } else if (error.message.includes('invalid data')) {
                            errorMessage += 'Statement generation produced invalid results. Please check the source data.';
                        } else {
                            errorMessage += error.message || 'Unknown error occurred.';
                        }
                        
                        display.innerHTML = `
                            <div style="padding: 20px; background: #f8d7da; border: 1px solid #dc3545; border-radius: 4px; color: #721c24;">
                                <strong>‚ùå Error:</strong> ${errorMessage}
                                <br><br>
                                <small>Check the browser console for more details.</small>
                            </div>
                        `;
                    }
                }
            }

            // Handle export all statements
            async handleExportAll() {
                try {
                    this.showExportStatus('Exporting all statements...', 'loading');

                    // Get years from config
                    const year1 = YEAR_CONFIG.getYear(0);
                    const year2 = YEAR_CONFIG.getYear(1);

                    // Get period selections from header dropdowns
                    const periodYear1 = document.getElementById(`period-${year1}-header`)?.value || `${year1}-all`;
                    const periodYear2 = document.getElementById(`period-${year2}-header`)?.value || `${year2}-all`;
                    const periodOptions = {
                        [`period${year1}`]: periodYear1,
                        [`period${year2}`]: periodYear2
                    };
                    
                    const statements = {
                        'Balance Sheet': this.statementGenerator.generateBalanceSheet(periodOptions),
                        'Income Statement': this.statementGenerator.generateIncomeStatement(periodOptions),
                        'Cash Flow': this.statementGenerator.generateCashFlowStatement(periodOptions)
                    };
                    
                    await this.exportHandler.exportAllStatements(statements);
                    
                    this.showExportStatus('All statements exported successfully!', 'success');
                    
                } catch (error) {
                    this.showExportStatus('Export failed: ' + error.message, 'error');
                    console.error('Export error:', error);
                }
            }

            // Show export status message
            showExportStatus(message, type) {
                const statusElement = document.getElementById('export-status');
                if (statusElement) {
                    statusElement.textContent = message;
                    
                    if (type === 'success') {
                        statusElement.style.color = '#28a745';
                    } else if (type === 'error') {
                        statusElement.style.color = '#dc3545';
                    } else if (type === 'loading') {
                        statusElement.style.color = '#007bff';
                    }
                    
                    // Clear message after 3 seconds
                    if (type !== 'loading') {
                        setTimeout(() => {
                            statusElement.textContent = '';
                        }, 3000);
                    }
                }
            }

            // Handle statement selection
            handleTabSwitch(statementType) {
                // Update dropdown selection
                const statementSelector = document.getElementById('statement-selector');
                if (statementSelector) {
                    statementSelector.value = statementType;
                }
                
                // Generate and display the selected statement
                this.generateAndDisplayStatement(statementType);
            }

            // Show data preview
            showDataPreview(fileId) {
                let table = null;
                let title = '';
                
                switch(fileId) {
                    case 'tb2024':
                        table = this.dataStore.getMovementsTable('2024');
                        title = 'Trial Balance 2024 Movements - First 20 Rows';
                        break;
                    case 'tb2025':
                        table = this.dataStore.getMovementsTable('2025');
                        title = 'Trial Balance 2025 Movements - First 20 Rows';
                        break;
                    case 'tb2425':
                        // Combine both movements tables
                        const tb2024m = this.dataStore.getMovementsTable('2024');
                        const tb2025m = this.dataStore.getMovementsTable('2025');
                        if (tb2024m && tb2025m) {
                            table = tb2024m.concat(tb2025m);
                            const rowCount = table.numRows();
                            title = `Combined Movements 2024+2025 - ${rowCount.toLocaleString()} rows (showing first 20)`;
                        }
                        break;
                }
                
                if (!table) {
                    return;
                }
                
                const previewDiv = document.getElementById('data-preview');
                const titleDiv = document.getElementById('preview-title');
                const contentDiv = document.getElementById('preview-content');
                
                titleDiv.textContent = title;
                
                // Get first 20 rows
                const rows = table.slice(0, 20).objects();
                const columns = table.columnNames();
                
                // Build table HTML
                let html = '<table><thead><tr>';
                columns.forEach(col => {
                    html += `<th>${col}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                rows.forEach(row => {
                    html += '<tr>';
                    columns.forEach(col => {
                        const value = row[col];
                        const displayValue = value !== null && value !== undefined ? value : '';
                        html += `<td>${displayValue}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                contentDiv.innerHTML = html;
                previewDiv.style.display = 'block';
            }

            // Setup event listeners
            setupEventListeners() {
                document.getElementById('select-input-dir').addEventListener('click', () => {
                    this.handleSelectInputDirectory();
                });

                // Statement selector dropdown
                const statementSelector = document.getElementById('statement-selector');
                if (statementSelector) {
                    statementSelector.addEventListener('change', () => {
                        this.handleTabSwitch(statementSelector.value);
                    });
                }

                // Export button
                document.getElementById('export-all').addEventListener('click', () => {
                    this.handleExportAll();
                });
                
                // File preview clicks
                document.querySelectorAll('.file-status-item.clickable').forEach(item => {
                    item.addEventListener('click', () => {
                        const fileId = item.dataset.file;
                        this.showDataPreview(fileId);
                    });
                });
                
                // Close preview button
                document.getElementById('close-preview').addEventListener('click', () => {
                    document.getElementById('data-preview').style.display = 'none';
                });
                
                // Variance toggle
                document.getElementById('show-variance')?.addEventListener('change', () => {
                    // Re-render the current statement
                    if (this.currentStatementType) {
                        this.handleTabSwitch(this.currentStatementType);
                    }
                });

                
                
                // Detail level dropdown is now in the table header and handled by the table's event listeners
            }
        }

        // Initialize application
        async function init() {
            console.log('Financial Statement Generator initialized');
            console.log('Arquero loaded:', typeof aq !== 'undefined');
            console.log('ExcelJS loaded:', typeof ExcelJS !== 'undefined');
            
            // Check browser compatibility
            if (!window.showDirectoryPicker) {
                alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
                console.error('File System Access API not supported');
            }
            
            // Load configuration
            await loadConfig();
            
            // Initialize UI Controller
            window.uiController = new UIController();
            window.uiController.setupEventListeners();
            
            // Initial state: disable export button until data is loaded
            document.getElementById('export-all').disabled = true;
            
            console.log('Application ready');
            console.log('Configuration:', config);
        }

        // Run initialization when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
