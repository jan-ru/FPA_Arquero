import Logger from '../utils/Logger.ts';

/**
 * ExportHandler - Legacy Excel export functionality
 *
 * @deprecated - No longer used. Export functionality moved to ag-Grid (AgGridStatementRenderer.exportToExcel)
 * Kept for reference only. Can be removed in future cleanup.
 *
 * This class was responsible for exporting financial statements to Excel format
 * using ExcelJS library. It has been superseded by ag-Grid's built-in export functionality.
 *
 * Depends on:
 * - ExcelJS (global from CDN)
 * - EXPORT_CONFIG constants
 * - config object (global)
 */

import { EXPORT_CONFIG } from '../constants.js';

class ExportHandler {
    constructor(dataStore) {
        this.dataStore = dataStore;
        // Use global EXPORT_CONFIG constants
    }

    // Helper: Format cells as whole numbers
    formatCellsAsNumbers(row, startCol, endCol) {
        for (let i = startCol; i <= endCol; i++) {
            if (row.getCell(i).value !== '' && row.getCell(i).value !== null) {
                row.getCell(i).numFmt = EXPORT_CONFIG.NUMBER_FORMAT;
            }
        }
    }

    // Helper: Style metric row (bold + highlighted)
    styleMetricRow(row, startCol, endCol, highlighted = true) {
        row.font = { bold: true };
        if (highlighted) {
            row.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: EXPORT_CONFIG.COLORS.METRIC_HIGHLIGHT }
            };
        }
        this.formatCellsAsNumbers(row, startCol, endCol);
    }

    // Convert Arquero table to array of arrays
    tableToArrays(table, includeHeaders = true) {
        const data = [];

        if (includeHeaders) {
            data.push(table.columnNames());
        }

        table.objects().forEach(row => {
            const rowArray = table.columnNames().map(col => row[col]);
            data.push(rowArray);
        });

        return data;
    }

    // Export all statements to single workbook
    async exportAllStatements(statements) {
        // Show loading indicator
        const exportStatus = document.getElementById('export-status');
        if (exportStatus) {
            exportStatus.textContent = '⏳ Generating Excel file...';
            exportStatus.style.color = '#007bff';
        }

        try {
            // Validate input
            if (!statements || Object.keys(statements).length === 0) {
                throw new Error('No statements available to export');
            }

            const workbook = new ExcelJS.Workbook();

            // Add metadata sheet first
            const metadataSheet = workbook.addWorksheet('Export Info');

            // Get current date and time
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Get username - browsers don't expose system username for security reasons
            // We'll use a placeholder that users can customize
            const username = 'System User';

            // Get input file names from config
            const inputFiles = [
                config.inputFiles.trialBalance2024,
                config.inputFiles.trialBalance2025,
                config.inputFiles.dates
            ];

            // Add metadata rows
            const metadataRows = [
                ['Financial Statements Export Information'],
                [''],
                ['Export Date:', dateStr],
                ['Export Time:', timeStr],
                ['Generated By:', username],
                [''],
                ['Input Files:'],
                ['Trial Balance 2024:', config.inputFiles.trialBalance2024],
                ['Trial Balance 2025:', config.inputFiles.trialBalance2025],
                ['Dates Dimension:', config.inputFiles.dates],
                [''],
                ['Statements Included:'],
                ['- Balance Sheet'],
                ['- Income Statement'],
                ['- Cash Flow Statement']
            ];

            metadataRows.forEach((row, index) => {
                const excelRow = metadataSheet.addRow(row);

                // Style the title row
                if (index === 0) {
                    excelRow.font = {
                        bold: true,
                        size: EXPORT_CONFIG.FONT_SIZES.TITLE,
                        color: { argb: EXPORT_CONFIG.COLORS.HEADER }
                    };
                }

                // Style section headers
                if (row[0] && (row[0].includes(':') || row[0].includes('Files') || row[0].includes('Included'))) {
                    excelRow.getCell(1).font = { bold: true };
                }
            });

            // Set column widths
            metadataSheet.getColumn(1).width = EXPORT_CONFIG.COLUMN_WIDTHS.METADATA_LABEL;
            metadataSheet.getColumn(2).width = EXPORT_CONFIG.COLUMN_WIDTHS.METADATA_VALUE;

            // Add each statement as a separate worksheet
            for (const [name, data] of Object.entries(statements)) {
                const worksheet = workbook.addWorksheet(name);

                // Determine if this is Cash Flow (2025 only, no variance)
                const isCashFlow = name === 'Cash Flow Statement';

                const headers = isCashFlow
                    ? ['Line Item', '2025']
                    : ['Line Item', '2024', '2025', 'Variance (€)', 'Variance (%)'];

                // Add header row
                const headerRow = worksheet.addRow(headers);
                headerRow.font = { bold: true, color: { argb: EXPORT_CONFIG.COLORS.WHITE } };
                headerRow.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: EXPORT_CONFIG.COLORS.HEADER }
                };

                // Center-align all column headers
                headerRow.eachCell((cell) => {
                    cell.alignment = { horizontal: 'center', vertical: 'middle' };
                });

                let rowIndex = 2; // Start after header
                const categoryStartRows = {}; // Track where each category starts for formulas
                const categoryEndRows = {}; // Track where each category ends for formulas

                // Add details
                const details = data.details.objects();
                let currentCategory = null;

                details.forEach(row => {
                    if (row.name1 !== currentCategory) {
                        // Mark end of previous category
                        if (currentCategory) {
                            categoryEndRows[currentCategory] = rowIndex - 1;
                        }

                        currentCategory = row.name1;
                        categoryStartRows[currentCategory] = rowIndex + 1; // +1 because category header is on current row

                        // Add category header
                        const categoryRow = worksheet.addRow([currentCategory, '', '', '', '']);
                        categoryRow.font = { bold: true };
                        rowIndex++;
                    }

                    // Add detail row
                    const detailRow = isCashFlow
                        ? ['  ' + (row.name2 || row.name1), row.amount_2025]
                        : ['  ' + (row.name2 || row.name1), row.amount_2024, row.amount_2025, row.variance_amount, row.variance_percent];

                    const excelRow = worksheet.addRow(detailRow);

                    // Format numbers as whole numbers
                    this.formatCellsAsNumbers(excelRow, 2, isCashFlow ? 2 : 5);
                    rowIndex++;
                });

                // Mark end of last category
                if (currentCategory) {
                    categoryEndRows[currentCategory] = rowIndex - 1;
                }

                // Add empty row
                worksheet.addRow(['', '', '', '', '']);
                rowIndex++;

                // Add calculated metrics if available
                if (data.metrics) {
                    const metrics = data.metrics;

                    // For Income Statement: Add Gross Profit, Operating Income, Net Income
                    if (name === 'Income Statement') {
                        if (metrics.grossProfit) {
                            const gpRow = worksheet.addRow(['Gross Profit', metrics.grossProfit['2024'], metrics.grossProfit['2025'], '', '']);
                            this.styleMetricRow(gpRow, 2, 3);
                            rowIndex++;
                        }

                        if (metrics.operatingIncome) {
                            const oiRow = worksheet.addRow(['Operating Income', metrics.operatingIncome['2024'], metrics.operatingIncome['2025'], '', '']);
                            this.styleMetricRow(oiRow, 2, 3);
                            rowIndex++;
                        }

                        if (metrics.netIncome) {
                            const niRow = worksheet.addRow(['Net Income', metrics.netIncome['2024'], metrics.netIncome['2025'], '', '']);
                            this.styleMetricRow(niRow, 2, 3);
                            rowIndex++;
                        }
                    }

                    // For Cash Flow: Add Starting Cash, Changes, Ending Cash
                    if (name === 'Cash Flow Statement') {
                        if (metrics.startingCash) {
                            const scRow = worksheet.addRow(['Starting Cash', metrics.startingCash['2025']]);
                            this.styleMetricRow(scRow, 2, 2, false);
                            rowIndex++;
                        }

                        if (metrics.changesInCash) {
                            const ccRow = worksheet.addRow(['Changes in Cash', metrics.changesInCash['2025']]);
                            this.styleMetricRow(ccRow, 2, 2, false);
                            rowIndex++;
                        }

                        if (metrics.endingCash) {
                            const ecRow = worksheet.addRow(['Ending Cash', metrics.endingCash['2025']]);
                            this.styleMetricRow(ecRow, 2, 2, true);
                            rowIndex++;
                        }
                    }
                }

                // Add empty row before totals
                worksheet.addRow(['', '', '', '', '']);
                rowIndex++;

                // Add category totals with Excel formulas
                const totals = data.totals.objects();
                totals.forEach(row => {
                    const totalLabel = 'Total ' + row.name1;
                    const startRow = categoryStartRows[row.name1];
                    const endRow = categoryEndRows[row.name1];

                    const totalRow = isCashFlow
                        ? worksheet.addRow([totalLabel, null])
                        : worksheet.addRow([totalLabel, null, null, null, null]);

                    totalRow.font = { bold: true };

                    // Add formulas or static values
                    if (startRow && endRow && startRow <= endRow) {
                        totalRow.getCell(2).value = { formula: `SUM(B${startRow}:B${endRow})` };

                        if (!isCashFlow) {
                            totalRow.getCell(3).value = { formula: `SUM(C${startRow}:C${endRow})` };
                            totalRow.getCell(4).value = { formula: `C${rowIndex}-B${rowIndex}` };
                            totalRow.getCell(5).value = { formula: `IF(B${rowIndex}=0,0,(D${rowIndex}/ABS(B${rowIndex}))*100)` };
                        }
                    } else {
                        // Fallback to static values
                        totalRow.getCell(2).value = isCashFlow ? row.amount_2025 : row.amount_2024;
                        if (!isCashFlow) {
                            totalRow.getCell(3).value = row.amount_2025;
                            totalRow.getCell(4).value = row.variance_amount;
                            totalRow.getCell(5).value = row.variance_percent;
                        }
                    }

                    // Format as whole numbers
                    this.formatCellsAsNumbers(totalRow, 2, isCashFlow ? 2 : 5);
                    rowIndex++;
                });

                // Set column widths
                worksheet.getColumn(1).width = EXPORT_CONFIG.COLUMN_WIDTHS.LINE_ITEM;
                worksheet.getColumn(2).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                if (!isCashFlow) {
                    worksheet.getColumn(3).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                    worksheet.getColumn(4).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                    worksheet.getColumn(5).width = EXPORT_CONFIG.COLUMN_WIDTHS.AMOUNT;
                }
            }

            // Generate buffer and download
            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], {
                type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            });

            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = config.outputFiles.allStatements;
            link.click();
            window.URL.revokeObjectURL(url);

            Logger.info('Exported all statements successfully');

            // Show success message
            if (exportStatus) {
                exportStatus.textContent = '✅ Export completed successfully';
                exportStatus.style.color = '#28a745';

                // Clear message after 3 seconds
                setTimeout(() => {
                    exportStatus.textContent = '';
                }, 3000);
            }

        } catch (error) {
            Logger.error('Error exporting all statements:', error);

            // Show user-friendly error message
            if (exportStatus) {
                let errorMessage = '❌ Export failed: ';

                if (error.message.includes('No statements')) {
                    errorMessage += 'No statements available. Please load data first.';
                } else if (error.message.includes('writeBuffer')) {
                    errorMessage += 'Failed to generate Excel file. Please try again.';
                } else if (error.message.includes('Blob')) {
                    errorMessage += 'Browser does not support file download.';
                } else {
                    errorMessage += error.message || 'Unknown error occurred.';
                }

                exportStatus.textContent = errorMessage;
                exportStatus.style.color = '#dc3545';

                // Keep error message visible longer
                setTimeout(() => {
                    exportStatus.textContent = '';
                }, 5000);
            }

            // Re-throw for debugging purposes
            throw error;
        }
    }
}

export default ExportHandler;
